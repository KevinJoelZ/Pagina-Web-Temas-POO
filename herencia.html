<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Herencia en POO - POO</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <header class="site-header">
    <nav class="navbar">
      <div class="brand"><a href="index.html">POO</a></div>
      <ul class="nav-links">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="fundamentos.html">Fundamentos</a></li>
        <li><a href="instanciacion.html">Instanciaci√≥n</a></li>
        <li><a href="herencia.html">Herencia</a></li>
        <li><a href="ejercicios.html">Ejercicios</a></li>
        <li><a href="ejercicios-en-clase.html">Ejercicios en Clase</a></li>
        <li><a href="ejercicios-temas-poo.html">Ejercicios Temas POO</a></li>
        <li><a href="trabajos-autonomos.html">Trabajos Aut√≥nomos</a></li>
        <li><a href="clase-practica.html">Clase Pr√°ctica</a></li>
        <li><a href="https://drive.google.com/drive/folders/175wdD0Z5zasjrHCy6rzqJpAT-K2fHqBW?hl=es" target="_blank" class="nav-videos">üé¨ Videos</a></li>
      </ul>
    </nav>
  </header>

  <main class="content">
    <h1>Conceptos Fundamentales de Herencia en POO</h1>

    <p>La herencia es uno de los pilares de la Programaci√≥n Orientada a Objetos. Permite que una clase herede atributos y m√©todos de otra, promoviendo reutilizaci√≥n de c√≥digo, extensibilidad y creaci√≥n de jerarqu√≠as bien estructuradas. En esta p√°gina aprender√°s c√≥mo funcionan las relaciones "es-un" entre clases.</p>

    <section id="que-es-herencia">
      <h2>¬øQu√© es la Herencia?</h2>
      <p><strong>Definici√≥n:</strong> La herencia es un mecanismo que permite que una clase (subclase o clase derivada) herede atributos y m√©todos de otra clase (superclase o clase base). La subclase extiende la funcionalidad de la superclase y puede agregar nuevos atributos y m√©todos, as√≠ como sobrescribir m√©todos existentes.</p>

      <h3>Relaci√≥n "es-un"</h3>
      <p>La herencia modelar una relaci√≥n "es-un". Por ejemplo: un <strong>Empleado es-un Persona</strong>, un <strong>Auto es-un Veh√≠culo</strong>. Esta relaci√≥n indica que la subclase es un tipo especial de la superclase, heredando todas sus caracter√≠sticas.</p>

      <div class="figure">
        <svg class="svg-illustration" viewBox="0 0 700 250" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Herencia - Superclase y Subclases">
          <rect x="250" y="20" width="200" height="80" rx="10" fill="#eef6ff" stroke="#0369a1" stroke-width="2"/>
          <text x="270" y="50" font-size="16" font-weight="700" fill="#0f1724">Persona (Superclase)</text>
          <text x="270" y="70" font-size="12" fill="#374151">nombre, edad</text>
          <text x="270" y="85" font-size="12" fill="#374151">saludar(), trabajar()</text>

          <rect x="50" y="150" width="180" height="80" rx="10" fill="#fff7ed" stroke="#d97706" stroke-width="2"/>
          <text x="70" y="180" font-size="14" font-weight="700" fill="#0f1724">Empleado</text>
          <text x="70" y="200" font-size="12" fill="#374151">+ salario, puesto</text>
          <text x="70" y="215" font-size="12" fill="#374151">+ calcularBono()</text>

          <rect x="310" y="150" width="180" height="80" rx="10" fill="#f0fdf4" stroke="#059669" stroke-width="2"/>
          <text x="330" y="180" font-size="14" font-weight="700" fill="#0f1724">Estudiante</text>
          <text x="330" y="200" font-size="12" fill="#374151">+ matricula, promedio</text>
          <text x="330" y="215" font-size="12" fill="#374151">+ estudiar()</text>

          <rect x="570" y="150" width="180" height="80" rx="10" fill="#faf5ff" stroke="#7c3aed" stroke-width="2"/>
          <text x="590" y="180" font-size="14" font-weight="700" fill="#0f1724">Doctor</text>
          <text x="590" y="200" font-size="12" fill="#374151">+ especialidad, licencia</text>
          <text x="590" y="215" font-size="12" fill="#374151">+ diagnosticar()</text>

          <path d="M350 100 L140 150" stroke="#374151" stroke-width="2" stroke-dasharray="5 5" marker-end="url(#arrowhead2)"/>
          <path d="M350 100 L400 150" stroke="#374151" stroke-width="2" stroke-dasharray="5 5" marker-end="url(#arrowhead2)"/>
          <path d="M370 100 L660 150" stroke="#374151" stroke-width="2" stroke-dasharray="5 5" marker-end="url(#arrowhead2)"/>

          <defs>
            <marker id="arrowhead2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#374151"/>
            </marker>
          </defs>

          <text x="200" y="125" font-size="11" fill="#6b7280" font-style="italic">extiende</text>
          <text x="360" y="125" font-size="11" fill="#6b7280" font-style="italic">extiende</text>
          <text x="500" y="125" font-size="11" fill="#6b7280" font-style="italic">extiende</text>
        </svg>
      </div>

      <h3>Conceptos B√°sicos de Herencia</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Superclase (Clase Base)</h4>
          <p>Clase de la que otras heredan. Define atributos y m√©todos comunes. Ejemplo: <code>Persona</code> es la superclase de <code>Empleado</code>, <code>Estudiante</code> y <code>Doctor</code>. Proporciona la estructura general y comportamiento compartido.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Subclase (Clase Derivada)</h4>
          <p>Clase que hereda de otra. Reutiliza c√≥digo de la superclase y agrega funcionalidad espec√≠fica. Ejemplo: <code>Empleado</code> hereda de <code>Persona</code> y agrega atributos como <code>salario</code>. Usa palabra clave <code>extends</code>.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Herencia Simple vs M√∫ltiple</h4>
          <p><strong>Java soporta herencia simple:</strong> una clase extiende solo una superclase. <strong>Herencia m√∫ltiple:</strong> no permitida en Java (para evitar ambig√ºedades), pero se logra mediante interfaces. En Java: <code>class Subclase extends Superclase</code>.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Reutilizaci√≥n de C√≥digo</h4>
          <p>No repites c√≥digo: si <code>Persona</code> tiene m√©todo <code>saludar()</code>, todos sus subclases lo heredan autom√°ticamente. Esto reduce duplicaci√≥n, facilita mantenimiento y asegura consistencia en toda la jerarqu√≠a.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Extensibilidad</h4>
          <p>Puedes agregar nuevos m√©todos y atributos en subclases sin modificar la superclase. Facilita la evoluci√≥n del c√≥digo: nuevas subclases pueden crearse seg√∫n cambien los requerimientos sin afectar c√≥digo existente.</p>
        </div>
      </div>
    </section>

    <section id="sintaxis-herencia">
      <h2>Sintaxis de Herencia en Java</h2>
      <p>La herencia en Java se declara con la palabra clave <code>extends</code>. Una clase que hereda extiende una superclase y obtiene acceso a todos sus miembros p√∫blicos y protegidos.</p>

      <h3>Estructura B√°sica</h3>
      <p><strong>Explicaci√≥n:</strong> Esta es la estructura b√°sica de herencia. <code>Persona</code> es la superclase que define atributos y m√©todos comunes. <code>Empleado</code> extiende <code>Persona</code> usando <code>extends</code>, heredando autom√°ticamente todos sus miembros. El constructor de <code>Empleado</code> debe llamar a <code>super()</code> para inicializar la superclase.</p>
      <pre><code class="language-java">// Superclase: define los datos y comportamientos comunes
public class Persona {
    // Atributo private: no heredable, solo accesible a trav√©s de m√©todos
    private String nombre;
    // Atributo private: no heredable
    private int edad;

    // Constructor: inicializa los atributos de Persona
    public Persona(String nombre, int edad) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
    }

    // Getter: retorna el nombre (heredable, accesible en subclases)
    public String getNombre() { return nombre; }
    // Getter: retorna la edad (heredable, accesible en subclases)
    public int getEdad() { return edad; }

    // M√©todo concreto: todas las subclases lo heredan
    public void saludar() {
        // Imprime un saludo usando el nombre de la persona
        System.out.println("Hola, soy " + nombre);
    }
}

// Subclase: extiende Persona usando la palabra clave extends
public class Empleado extends Persona {
    // Atributo private: espec√≠fico de Empleado
    private double salario;
    // Atributo private: espec√≠fico de Empleado
    private String puesto;

    // Constructor de Empleado: recibe par√°metros de Persona + par√°metros propios
    public Empleado(String nombre, int edad, double salario, String puesto) {
        // Llama OBLIGATORIAMENTE al constructor de la superclase (Persona) como primera l√≠nea
        // super() inicializa los atributos heredados (nombre, edad)
        super(nombre, edad);
        // Asigna el salario espec√≠fico de Empleado
        this.salario = salario;
        // Asigna el puesto espec√≠fico de Empleado
        this.puesto = puesto;
    }

    // Getter: retorna el salario
    public double getSalario() { return salario; }
    // Getter: retorna el puesto
    public String getPuesto() { return puesto; }

    // M√©todo nuevo en Empleado: no exist√≠a en Persona
    public double calcularBono() {
        // Calcula y retorna el 10% del salario como bonus
        return salario * 0.10;
    }
}
</code></pre>

      <h3>Elementos Clave en la Sintaxis</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Palabra Clave extends</h4>
          <p>Sintaxis: <code>public class Subclase extends Superclase { ... }</code>. Indica que <code>Subclase</code> hereda de <code>Superclase</code>. Java permite una sola superclase por clase. Define relaci√≥n "es-un".</p>
        </div>
        <div class="card-profesional-green">
          <h4>Palabra Clave super</h4>
          <p>Referencia a la superclase. √ösala para: 1) Llamar constructor de superclase: <code>super(par√°metros)</code>. 2) Acceder m√©todos de superclase: <code>super.m√©todo()</code>. 3) Acceder atributos: <code>super.atributo</code>. Debes usar <code>super()</code> como primera l√≠nea en constructor de subclase.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Accesibilidad: private vs protected</h4>
          <p><code>private</code>: solo la clase, NO heredable. <code>protected</code>: la clase, subclases y mismo paquete, S√ç heredable. <code>public</code>: heredable desde cualquier lugar. <code>default</code>: heredable solo en mismo paquete. Para herencia, prefiere <code>protected</code> en superclases.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Modificador final</h4>
          <p><code>final</code> en clase: no puede ser extendida. <code>final</code> en m√©todo: no puede ser sobrescrito. <code>final</code> en atributo: no puede cambiar. Usa <code>final</code> cuando NO quieras que se hereden o modifiquen. Ejemplo: <code>String</code> en Java es final.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Constructor en Herencia</h4>
          <p>Subclases NO heredan constructores autom√°ticamente. Debes definir tu propio constructor en subclase y llamar <code>super(par√°metros)</code> para inicializar la superclase. Si superclase tiene constructor sin par√°metros, Java llama autom√°ticamente.</p>
        </div>
      </div>

      <h3>Ejemplo Completo: Jerarqu√≠a de Veh√≠culos</h3>
      <p><strong>Explicaci√≥n:</strong> Este ejemplo muestra una jerarqu√≠a de tres niveles. <code>Veh√≠culo</code> es la superclase base. <code>Auto</code> y <code>Moto</code> son subclases que heredan de <code>Veh√≠culo</code> y agregan atributos/m√©todos espec√≠ficos. Demuestra c√≥mo reutilizar c√≥digo y especializar comportamiento.</p>
      <pre><code class="language-java">// Superclase: define los datos y comportamientos comunes de todos los veh√≠culos
public class Veh√≠culo {
    // Atributo private: marca del veh√≠culo
    private String marca;
    // Atributo private: modelo del veh√≠culo
    private String modelo;
    // Atributo private: a√±o de fabricaci√≥n
    private int a√±o;

    // Constructor: inicializa un veh√≠culo con marca, modelo y a√±o
    public Veh√≠culo(String marca, String modelo, int a√±o) {
        // Asigna la marca
        this.marca = marca;
        // Asigna el modelo
        this.modelo = modelo;
        // Asigna el a√±o
        this.a√±o = a√±o;
    }

    // M√©todo concreto: muestra informaci√≥n del veh√≠culo (heredable)
    public void mostrarInfo() {
        // Imprime marca, modelo y a√±o formateado
        System.out.println(marca + " " + modelo + " (" + a√±o + ")");
    }

    // M√©todo concreto: acci√≥n de arrancar (heredable por todas las subclases)
    public void arrancar() {
        // Imprime mensaje gen√©rico de arranque
        System.out.println("El veh√≠culo est√° arrancando...");
    }
}

// Subclase 1: Auto extiende Veh√≠culo
public class Auto extends Veh√≠culo {
    // Atributo private: n√∫mero de puertas del auto
    private int puertas;

    // Constructor: recibe par√°metros de Veh√≠culo + par√°metros de Auto
    public Auto(String marca, String modelo, int a√±o, int puertas) {
        // Llama al constructor de Veh√≠culo (superclase) con sus par√°metros
        super(marca, modelo, a√±o);
        // Asigna el n√∫mero de puertas espec√≠fico de Auto
        this.puertas = puertas;
    }

    // Getter: retorna el n√∫mero de puertas
    public int getPuertas() { return puertas; }

    // M√©todo nuevo espec√≠fico de Auto: no existe en Veh√≠culo
    public void abrirMaletero() {
        // Imprime que se abre el maletero
        System.out.println("Maletero del auto abierto");
    }
}

// Subclase 2: Moto extiende Veh√≠culo
public class Moto extends Veh√≠culo {
    // Atributo private: booleano que indica si la moto tiene sidecar
    private boolean tieneSidecar;

    // Constructor: recibe par√°metros de Veh√≠culo + par√°metros de Moto
    public Moto(String marca, String modelo, int a√±o, boolean tieneSidecar) {
        // Llama al constructor de Veh√≠culo (superclase) con sus par√°metros
        super(marca, modelo, a√±o);
        // Asigna si tiene sidecar
        this.tieneSidecar = tieneSidecar;
    }

    // Getter: retorna si la moto tiene sidecar
    public boolean tieneSidecar() { return tieneSidecar; }

    // M√©todo nuevo espec√≠fico de Moto: no existe en Veh√≠culo
    public void hacerCaballito() {
        // Imprime acci√≥n caracter√≠stica de motos
        System.out.println("¬°La moto est√° haciendo caballito!");
    }
}

// Clase de uso: demuestra la herencia en acci√≥n
public class Main {
    // M√©todo main: punto de entrada del programa
    public static void main(String[] args) {
        // Crea una instancia de Auto
        Auto auto = new Auto("Toyota", "Corolla", 2023, 4);
        // Llama m√©todo heredado de Veh√≠culo
        auto.mostrarInfo();    // Heredado de Veh√≠culo - imprime: Toyota Corolla (2023)
        // Llama otro m√©todo heredado de Veh√≠culo
        auto.arrancar();       // Heredado de Veh√≠culo - imprime: El veh√≠culo est√° arrancando...
        // Llama m√©todo espec√≠fico de Auto
        auto.abrirMaletero();  // M√©todo de Auto - imprime: Maletero del auto abierto

        // Crea una instancia de Moto
        Moto moto = new Moto("Honda", "CB500", 2022, false);
        // Llama m√©todo heredado de Veh√≠culo
        moto.mostrarInfo();    // Heredado de Veh√≠culo - imprime: Honda CB500 (2022)
        // Llama m√©todo espec√≠fico de Moto
        moto.hacerCaballito(); // M√©todo de Moto - imprime: ¬°La moto est√° haciendo caballito!
    }
}
</code></pre>
    </section>

    <section id="sobrescritura-metodos">
      <h2>Sobrescritura (Override) de M√©todos</h2>
      <p>La sobrescritura permite que una subclase proporcione su propia implementaci√≥n de un m√©todo heredado. El m√©todo de la subclase reemplaza el de la superclase cuando se invoca en un objeto de la subclase. Es fundamental para polimorfismo.</p>

      <h3>Principios de Sobrescritura</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Override Annotation</h4>
          <p>Usa <code>@Override</code> para indicar que sobrescribes un m√©todo. No es obligatorio pero es buena pr√°ctica. El compilador verifica que el m√©todo existe en la superclase. Si cometes error en la firma, el compilador lo detecta.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Firma Id√©ntica</h4>
          <p>El m√©todo sobrescrito debe tener exactamente la misma firma: mismo nombre, mismos par√°metros, mismo tipo de retorno. Si cambias la firma, NO es sobrescritura, es sobrecarga (otro concepto). La firma debe ser id√©ntica para que el polimorfismo funcione.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Acceso M√°s Permisivo</h4>
          <p>El modificador de acceso del m√©todo sobrescrito debe ser igual o m√°s permisivo. Ejemplo: si superclase tiene <code>protected</code>, subclase puede tener <code>protected</code> o <code>public</code>, pero NO <code>private</code>. Garantiza que subclases no restrinjan acceso.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>No Cambiar Tipo de Retorno</h4>
          <p>El tipo de retorno debe ser id√©ntico o covariant (subtipo del tipo original). Java permite que retornes un subtipo del retorno original. Ejemplo: si superclase retorna <code>Persona</code>, subclase puede retornar <code>Empleado</code> (si Empleado extiende Persona).</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Excepciones Lanzadas</h4>
          <p>El m√©todo sobrescrito puede lanzar excepciones iguales o m√°s espec√≠ficas (subtipos) que el m√©todo de la superclase. No puedes lanzar excepciones m√°s generales. Esto asegura compatibilidad: c√≥digo que usa el m√©todo no se sorprende con excepciones inesperadas.</p>
        </div>
      </div>

      <h3>Ejemplo: Sobrescritura en Acci√≥n</h3>
      <p><strong>Explicaci√≥n:</strong> Este ejemplo demuestra polimorfismo mediante sobrescritura. La superclase <code>Animal</code> define un m√©todo <code>hacerSonido()</code> gen√©rico. Las subclases <code>Perro</code> y <code>Gato</code> sobrescriben este m√©todo con su propio comportamiento. Cuando se invoca <code>hacerSonido()</code> en tiempo de ejecuci√≥n, se ejecuta la versi√≥n espec√≠fica de cada clase.</p>
      <pre><code class="language-java">// Superclase: define el comportamiento com√∫n
public class Animal {
    // Atributo private: nombre del animal
    private String nombre;

    // Constructor: inicializa el animal con un nombre
    public Animal(String nombre) {
        // Asigna el nombre
        this.nombre = nombre;
    }

    // Getter: retorna el nombre
    public String getNombre() { return nombre; }

    // M√©todo concreto: versi√≥n gen√©rica (ser√° sobrescrita en subclases)
    public void hacerSonido() {
        // Mensaje gen√©rico de sonido
        System.out.println("El animal hace un sonido gen√©rico");
    }
}

// Subclase 1: Perro extiende Animal
public class Perro extends Animal {
    // Constructor: recibe el nombre y lo pasa a la superclase
    public Perro(String nombre) {
        // Llama al constructor de Animal con el nombre
        super(nombre);
    }

    // Sobrescritura: proporciona implementaci√≥n espec√≠fica de hacerSonido para Perro
    // @Override indica que sobrescribimos un m√©todo de la superclase
    @Override
    public void hacerSonido() {
        // Imprime el sonido espec√≠fico de un perro usando el nombre heredado
        System.out.println(getNombre() + " ladra: ¬°guau guau!");
    }
}

// Subclase 2: Gato extiende Animal
public class Gato extends Animal {
    // Constructor: recibe el nombre y lo pasa a la superclase
    public Gato(String nombre) {
        // Llama al constructor de Animal con el nombre
        super(nombre);
    }

    // Sobrescritura: proporciona implementaci√≥n espec√≠fica de hacerSonido para Gato
    @Override
    public void hacerSonido() {
        // Imprime el sonido espec√≠fico de un gato
        System.out.println(getNombre() + " ma√∫lla: ¬°miau!");
    }
}

// Clase de uso: demuestra el polimorfismo en acci√≥n
public class Main {
    // M√©todo main: punto de entrada
    public static void main(String[] args) {
        // Crea referencia de tipo Animal pero objeto Perro (polimorfismo)
        Animal perro = new Perro("Max");
        // Crea referencia de tipo Animal pero objeto Gato (polimorfismo)
        Animal gato = new Gato("Misi");

        // Invoca hacerSonido() en el perro
        // En tiempo de ejecuci√≥n, invoca el m√©todo sobrescrito de Perro
        perro.hacerSonido();  // Salida: Max ladra: ¬°guau guau!
        
        // Invoca hacerSonido() en el gato
        // En tiempo de ejecuci√≥n, invoca el m√©todo sobrescrito de Gato
        gato.hacerSonido();   // Salida: Misi ma√∫lla: ¬°miau!
        
        // Ambos son Animal, pero cada uno se comporta diferente
        // El m√©todo invocado depende del tipo real del objeto en tiempo de ejecuci√≥n
    }
}
</code></pre>
    </section>

    <section id="polimorfismo">
      <h2>Polimorfismo mediante Herencia</h2>
      <p>Polimorfismo significa "muchas formas". En el contexto de herencia, permite que objetos de diferentes subclases respondan al mismo mensaje (m√©todo) de manera diferente. Es una consecuencia poderosa de la herencia y sobrescritura de m√©todos.</p>

      <h3>Tipos y Beneficios del Polimorfismo</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Polimorfismo de Compilaci√≥n (Sobrecarga)</h4>
          <p>M√∫ltiples m√©todos con el mismo nombre pero diferentes par√°metros. El compilador elige cu√°l invocar seg√∫n los argumentos. Ocurre en tiempo de compilaci√≥n. Ejemplo: <code>System.out.println()</code> acepta int, String, double, etc.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Polimorfismo de Ejecuci√≥n (Sobrescritura)</h4>
          <p>M√©todo invocado en tiempo de ejecuci√≥n seg√∫n el tipo real del objeto, NO el tipo de la variable. Requiere herencia y sobrescritura. Ejemplo: <code>Animal a = new Perro()</code>; <code>a.hacerSonido()</code> invoca el m√©todo de Perro, no el de Animal.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Referencia Superclase, Objeto Subclase</h4>
          <p>Puedes asignar objeto de subclase a variable de tipo superclase: <code>Persona p = new Empleado(...)</code>. La variable <code>p</code> ve solo miembros de Persona, pero invoca m√©todos del Empleado real. Fundamental para dise√±o flexible.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Beneficios del Polimorfismo</h4>
          <p><strong>1) Flexibilidad:</strong> C√≥digo gen√©rico funciona con m√∫ltiples tipos. <strong>2) Extensibilidad:</strong> Agregar nuevas subclases sin cambiar c√≥digo existente. <strong>3) Mantenibilidad:</strong> Menos duplicaci√≥n, cambios en un lugar. <strong>4) Reusabilidad:</strong> M√©todos gen√©ricos reutilizables.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Ejemplo: Colecciones Polim√≥rficas</h4>
          <p>Puedes almacenar diferentes subclases en un contenedor de la superclase: <code>List&lt;Animal&gt; animales = new ArrayList&lt;&gt;()</code>; <code>animales.add(new Perro(...))</code>; <code>animales.add(new Gato(...))</code>. Itera y invoca m√©todos: cada objeto responde apropiadamente.</p>
        </div>
      </div>

      <h3>Ejemplo Completo: Gesti√≥n de Empleados</h3>
      <p><strong>Explicaci√≥n:</strong> Este es un ejemplo completo que demuestra polimorfismo en un contexto real. <code>Empleado</code> es una clase abstracta que define el contrato. Las subclases (EmpleadoOficina, Vendedor) implementan <code>calcularBonus()</code> diferente. La clase <code>GestorEmpleados</code> demuestra polimorfismo: trabaja con referencias de <code>Empleado</code> pero ejecuta m√©todos espec√≠ficos de cada subclase.</p>
      <pre><code class="language-java">// Importar ArrayList y List
import java.util.ArrayList;
import java.util.List;

// Superclase abstracta: define el contrato que todas las subclases deben cumplir
public abstract class Empleado {
    // Atributo protected: heredable por subclases
    protected String nombre;
    // Atributo protected: heredable por subclases
    protected double salario;

    // Constructor: inicializa nombre y salario
    public Empleado(String nombre, double salario) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna el salario
        this.salario = salario;
    }

    // M√©todo abstracto: cada subclase debe implementarlo
    public abstract double calcularBonus();

    // Sobrescribe toString para representaci√≥n legible
    @Override
    public String toString() {
        // Retorna nombre, salario formateado
        return nombre + " - Salario: $" + salario;
    }
}

// Subclase 1: EmpleadoOficina
public class EmpleadoOficina extends Empleado {
    // Atributo private: horas extra trabajadas
    private int horasExtra;

    // Constructor: recibe par√°metros de Empleado + horasExtra
    public EmpleadoOficina(String nombre, double salario, int horasExtra) {
        // Llama constructor de Empleado
        super(nombre, salario);
        // Asigna horas extra
        this.horasExtra = horasExtra;
    }

    // Implementaci√≥n espec√≠fica de calcularBonus para oficina
    @Override
    public double calcularBonus() {
        // Retorna 15% del salario + $50 por cada hora extra
        return salario * 0.15 + (horasExtra * 50);
    }
}

// Subclase 2: Vendedor
public class Vendedor extends Empleado {
    // Atributo private: total de ventas realizadas
    private double ventasRealizadas;

    // Constructor: recibe par√°metros de Empleado + ventasRealizadas
    public Vendedor(String nombre, double salario, double ventasRealizadas) {
        // Llama constructor de Empleado
        super(nombre, salario);
        // Asigna ventas realizadas
        this.ventasRealizadas = ventasRealizadas;
    }

    // Implementaci√≥n espec√≠fica de calcularBonus para vendedores
    @Override
    public double calcularBonus() {
        // Retorna 5% de comisi√≥n sobre las ventas realizadas
        return ventasRealizadas * 0.05; // 5% de comisi√≥n
    }
}

// Clase que gestiona empleados de forma polim√≥rfica
public class GestorEmpleados {
    // Lista que almacena referencias de tipo Empleado (puede contener cualquier subclase)
    private List&lt;Empleado&gt; empleados = new ArrayList&lt;&gt;();

    // M√©todo para agregar un empleado (de cualquier tipo) a la lista
    public void agregarEmpleado(Empleado e) {
        // Agrega el empleado a la lista (puede ser EmpleadoOficina, Vendedor, etc)
        empleados.add(e);
    }

    // M√©todo que muestra bonus de todos los empleados (polim√≥rfico)
    public void mostrarBonus() {
        // Itera sobre cada empleado en la lista
        for (Empleado e : empleados) {
            // Imprime empleado y su bonus
            // calcularBonus() se invoca polim√≥rficamente: cada tipo ejecuta su versi√≥n
            System.out.println(e + " - Bonus: $" + e.calcularBonus());
        }
    }
}

// Clase de uso: demuestra el sistema en acci√≥n
public class Main {
    // M√©todo main: punto de entrada
    public static void main(String[] args) {
        // Crea instancia del gestor
        GestorEmpleados gestor = new GestorEmpleados();

        // Crea y agrega un EmpleadoOficina
        // Agrupa nombre, salario, horasExtra
        gestor.agregarEmpleado(new EmpleadoOficina("Ana", 2000, 10));
        
        // Crea y agrega un Vendedor
        // Agrupa nombre, salario, ventasRealizadas
        gestor.agregarEmpleado(new Vendedor("Carlos", 1500, 5000));

        // Muestra bonus de todos los empleados
        // El gestor no conoce tipos espec√≠ficos, pero cada uno calcula bonus correcto
        gestor.mostrarBonus();
        // Salida esperada:
        // Ana - Salario: $2000.0 - Bonus: $500.0
        // Carlos - Salario: $1500.0 - Bonus: $250.0
    }
}
</code></pre>
    </section>

    <section id="modificadores-acceso">
      <h2>Modificadores de Acceso en Herencia</h2>
      <p>Los modificadores de acceso (<code>private</code>, <code>protected</code>, <code>public</code>, default) controlan qu√© miembros de una clase son accesibles en subclases. Entender esto es crucial para un buen dise√±o de jerarqu√≠as de herencia.</p>

      <h3>Modificadores de Acceso Explicados</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>private (Privado)</h4>
          <p>Acceso <strong>solo en la clase.</strong> <strong>NO heredable.</strong> Subclases NO pueden acceder directamente. Para acceder, debe ir a trav√©s de m√©todos p√∫blicos/protegidos. Proporciona m√°xima encapsulaci√≥n. Ejemplo: detalles internos de implementaci√≥n.</p>
        </div>
        <div class="card-profesional-green">
          <h4>protected (Protegido)</h4>
          <p>Acceso en: la clase, subclases, mismo paquete. <strong>S√ç heredable.</strong> Ideal para members que quieres que hereden subclases pero no sean p√∫blicos. Menos restrictivo que private. √ösalo en superclases para datos/m√©todos que subclases necesitan.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>public (P√∫blico)</h4>
          <p>Acceso <strong>desde cualquier lugar.</strong> <strong>S√ç heredable.</strong> Parte de la interfaz p√∫blica de la clase. √ösalo para m√©todos de API que todas las clases usan. Menos restrictivo. Cambios pueden afectar mucho c√≥digo externo.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>default (Sin modificador)</h4>
          <p>Acceso en la clase y <strong>mismo paquete.</strong> <strong>S√ç heredable dentro del paquete.</strong> Si subclase est√° en otro paquete, NO hereda. √ötil para miembros que son internos al paquete pero no p√∫blicos globalmente.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Tabla de Acceso en Herencia</h4>
          <p><code>private</code>: ‚ùå NO heredable. <code>protected</code>: ‚úÖ Heredable. <code>public</code>: ‚úÖ Heredable. <code>default</code>: ‚úÖ Heredable (mismo paquete solo). Regla: prefiere el nivel de acceso m√°s restrictivo posible para maximizar seguridad.</p>
        </div>
      </div>

      <h3>Ejemplo: Modificadores en Jerarqu√≠a</h3>
      <p><strong>Explicaci√≥n:</strong> Este ejemplo muestra c√≥mo funcionan los diferentes modificadores de acceso en una jerarqu√≠a de herencia. <code>private</code> NO es heredable, <code>protected</code> es heredable, <code>public</code> es heredable. La clase <code>Empleado</code> intenta acceder a diferentes miembros de <code>Persona</code>.</p>
      <pre><code class="language-java">// Superclase con diferentes modificadores de acceso
public class Persona {
    // Atributo private: NO heredable, solo accesible dentro de Persona
    private String numeroDocumento;
    
    // Atributo protected: heredable, accesible en subclases
    protected String nombre;
    
    // Atributo public: heredable, accesible desde cualquier lugar
    public int edad;
    
    // Atributo default (sin modificador): heredable solo en mismo paquete
    int id;

    // M√©todo protected: heredable, implementaci√≥n puede ser de subclases
    protected void saludar() {
        // Imprime saludo
        System.out.println("Hola");
    }

    // M√©todo private: NO heredable, solo accesible dentro de Persona
    private void detallePersonal() {
        // Imprime detalles personales
        System.out.println("Este es privado");
    }
}

// Subclase que intenta acceder a miembros de Persona
public class Empleado extends Persona {
    // M√©todo que intenta acceder a miembros heredados
    public void mostrarDatos() {
        // ‚úÖ OK - protected: heredable y accesible en subclases
        System.out.println(nombre);              // Acceso permitido
        
        // ‚úÖ OK - public: heredable y accesible desde cualquier lugar
        System.out.println(edad);                // Acceso permitido
        
        // ‚ùå ERROR - private: NO heredable, no accesible en subclases
        // System.out.println(numeroDocumento);  // COMPILAR√çA ERROR
        
        // ‚úÖ OK - protected: heredable, puede llamarse m√©todo heredado
        saludar();                               // Acceso permitido
        
        // ‚ùå ERROR - private: NO heredable, no accesible en subclases
        // detallePersonal();                    // COMPILAR√çA ERROR
    }
}
</code></pre>
    </section>

    <section id="ejercicios">
      <h2>Ejercicios Pr√°cticos</h2>

      <h3>Ejercicio 1: Jerarqu√≠a de Figuras Geom√©tricas</h3>
      <p><strong>Enunciado:</strong> Crea una superclase abstracta <code>Figura</code> con m√©todos abstractos <code>calcularArea()</code> y <code>calcularPerimetro()</code>. Implementa <code>Rect√°ngulo</code> y <code>C√≠rculo</code>.</p>

      <div class="solution">
        <pre><code class="language-java">// Superclase abstracta
abstract class Figura {
    protected String nombre;
    public Figura(String nombre) { this.nombre = nombre; }
    
    // M√©todos abstractos - cada subclase implementa
    public abstract double calcularArea();
    public abstract double calcularPerimetro();
    
    @Override
    public String toString() { return nombre; }
}

// Subclase 1: Rect√°ngulo
class Rectangulo extends Figura {
    private double ancho, alto;
    public Rectangulo(double ancho, double alto) {
        super("Rect√°ngulo");
        this.ancho = ancho;
        this.alto = alto;
    }
    
    @Override
    public double calcularArea() { return ancho * alto; }
    
    @Override
    public double calcularPerimetro() { return 2 * (ancho + alto); }
}

// Subclase 2: C√≠rculo
class Circulo extends Figura {
    private double radio;
    public Circulo(double radio) {
        super("C√≠rculo");
        this.radio = radio;
    }
    
    @Override
    public double calcularArea() { return Math.PI * radio * radio; }
    
    @Override
    public double calcularPerimetro() { return 2 * Math.PI * radio; }
}

// Programa principal
public class Main {
    public static void main(String[] args) {
        // Polimorfismo: lista de Figuras puede contener cualquier subclase
        Figura[] figuras = {
            new Rectangulo(5, 3),
            new Circulo(4)
        };
        
        // Iterar sobre figuras - cada una responde apropiadamente
        for (Figura f : figuras) {
            System.out.println(f + " - √Årea: " + String.format("%.2f", f.calcularArea()) + 
                             " - Per√≠metro: " + String.format("%.2f", f.calcularPerimetro()));
        }
    }
}
</code></pre>
      </div>

      <h3>Ejercicio 2: Sistema Bancario con Herencia</h3>
      <p><strong>Enunciado:</strong> Superclase abstracta <code>CuentaBancaria</code> con <code>depositar()</code>, <code>retirar()</code> y <code>calcularInteres()</code>. Subclases: <code>CuentaAhorro</code> (5% inter√©s) y <code>CuentaCorriente</code> (sin inter√©s, permite descubierto).</p>

      <div class="solution">
        <pre><code class="language-java">// Superclase abstracta
abstract class CuentaBancaria {
    protected String numero, titular;
    protected double saldo;
    
    public CuentaBancaria(String numero, String titular, double saldo) {
        this.numero = numero;
        this.titular = titular;
        this.saldo = saldo;
    }
    
    // M√©todo concreto: todas las cuentas lo heredan
    public void depositar(double monto) {
        if (monto > 0) saldo += monto;
    }
    
    // M√©todos abstractos: cada subclase implementa diferente
    public abstract boolean retirar(double monto);
    public abstract double calcularInteres();
    
    public double getSaldo() { return saldo; }
    
    @Override
    public String toString() { return titular + " - Saldo: $" + saldo; }
}

// Subclase 1: Cuenta de Ahorro - 5% inter√©s, no permite descubierto
class CuentaAhorro extends CuentaBancaria {
    public CuentaAhorro(String numero, String titular, double saldo) {
        super(numero, titular, saldo);
    }
    
    @Override
    public boolean retirar(double monto) {
        if (monto > 0 && monto <= saldo) {
            saldo -= monto;
            return true;
        }
        return false;
    }
    
    @Override
    public double calcularInteres() { return saldo * 0.05; } // 5% anual
}

// Subclase 2: Cuenta Corriente - sin inter√©s, permite descubierto
class CuentaCorriente extends CuentaBancaria {
    private double limite = 500; // Permite hasta $500 de descubierto
    
    public CuentaCorriente(String numero, String titular, double saldo) {
        super(numero, titular, saldo);
    }
    
    @Override
    public boolean retirar(double monto) {
        if (monto > 0 && monto <= (saldo + limite)) {
            saldo -= monto;
            return true;
        }
        return false;
    }
    
    @Override
    public double calcularInteres() { return 0; } // Sin inter√©s
}

// Programa principal
public class Main {
    public static void main(String[] args) {
        CuentaBancaria c1 = new CuentaAhorro("001", "Ana", 1000);
        CuentaBancaria c2 = new CuentaCorriente("002", "Carlos", 500);
        
        // Dep√≥sitos
        c1.depositar(200);
        c2.depositar(300);
        
        // Retiros
        c1.retirar(100);
        c2.retirar(100);
        
        // Mostrar informaci√≥n con polimorfismo
        System.out.println(c1 + " - Inter√©s: $" + String.format("%.2f", c1.calcularInteres()));
        System.out.println(c2 + " - Inter√©s: $" + String.format("%.2f", c2.calcularInteres()));
    }
}
</code></pre>
      </div>
    </section>

    <h3>Cards de Refuerzo: Herencia</h3>
    <div class="cards-grid-teoricos">
      <div class="card-teorico">
        <h4>Herencia: Reutilizaci√≥n</h4>
        <p>Evita repetici√≥n de c√≥digo compartiendo estructura entre clases relacionadas. Cambia en un lugar, afecta a todas las subclases. Menos bugs, m√°s mantenible.</p>
      </div>
      <div class="card-teorico">
        <h4>extends: Una Superclase</h4>
        <p>Java permite una sola superclase por clase. Una subclase hereda de exactamente una clase. Crea jerarqu√≠as simples, f√°ciles de seguir y entender.</p>
      </div>
      <div class="card-teorico">
        <h4>super: Conexi√≥n a Superclase</h4>
        <p>Referencia a miembros de la superclase. Llama constructor de superclase en primera l√≠nea de constructor de subclase. Accede m√©todos sobrescritos si necesitas.</p>
      </div>
      <div class="card-teorico">
        <h4>@Override: Sobrescritura Expl√≠cita</h4>
        <p>Anotaci√≥n que indica intenci√≥n de sobrescribir. Compilador verifica la firma. Si cometes error, el compilador lo detecta. Buena pr√°ctica de c√≥digo claro.</p>
      </div>
      <div class="card-teorico">
        <h4>Polimorfismo: Muchas Formas</h4>
        <p>C√≥digo gen√©rico con referencias de superclase trabaja con m√∫ltiples subclases. Cada objeto responde apropiadamente seg√∫n su tipo real. Flexible y extensible.</p>
      </div>
      <div class="card-teorico">
        <h4>protected: Para Subclases</h4>
        <p>Miembros protected son heredables. Usa en superclases para datos que subclases necesitan acceder directamente, pero que no deben ser p√∫blicos.</p>
      </div>
    </div>

    <h3>Buenas Pr√°cticas en Herencia</h3>
    <div class="info-box">
      <ol>
        <li><strong>Relaci√≥n "es-un" aut√©ntica:</strong> Solo hereda si existe relaci√≥n verdadera. No fuerces herencia solo para reutilizar c√≥digo; considera composici√≥n.</li>
        <li><strong>Evita jerarqu√≠as profundas:</strong> Mant√©n profundidad ‚â§ 3 niveles. Jerarqu√≠as profundas son complejas y dif√≠ciles de mantener.</li>
        <li><strong>Usa classes abstractas para definir contratos:</strong> Si una clase no debe instanciarse directamente, hazla <code>abstract</code>. Define m√©todos abstractos para obligar a subclases a implementarlos.</li>
        <li><strong>Preferir composici√≥n cuando sea apropiado:</strong> Si necesitas m√∫ltiples comportamientos, composici√≥n es m√°s flexible que herencia m√∫ltiple (que Java no soporta).</li>
        <li><strong>Documenta la jerarqu√≠a:</strong> Deja clara la relaci√≥n entre superclase y subclases. Especifica qu√© m√©todos heredan, cu√°les se sobreescriben.</li>
        <li><strong>No violes el contrato de la superclase:</strong> M√©todos sobrescritos deben mantener sem√°ntica compatible. No cambies comportamiento esperado de manera radical.</li>
        <li><strong>Usa final juiciosamente:</strong> Hazlo <code>final</code> si no quieres que se herede o si herede rompe contrato. Pero no lo hagas por defecto.</li>
      </ol>
    </div>

    <section id="videos-educativos">
      <h2>Videos Educativos</h2>
      <div class="videos-grid">
        <div class="video-container">
          <h3>Herencia en Java</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/herencia.mp4" type="video/mp4">
              Tu navegador no soporta la reproducci√≥n de video. <a href="videos/herencia.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Aprende los conceptos fundamentales de la herencia en Java.</p>
        </div>
      </div>
    </section>

    <div style="text-align:center;margin:40px 0;padding:25px;background:linear-gradient(135deg,rgba(43,108,176,0.08),rgba(72,187,120,0.05));border-radius:12px;border:2px solid rgba(43,108,176,0.15);">
      <p style="margin:0 0 15px 0;font-weight:600;color:var(--accent);">üìö Recursos adicionales</p>
      <p class="muted" style="margin:0 0 20px 0;"><a href="https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html" target="_blank" rel="noopener">Subclasses (Oracle)</a> ‚Ä¢ <a href="https://www.geeksforgeeks.org/inheritance-in-java/" target="_blank" rel="noopener">Inheritance in Java (GeeksforGeeks)</a></p>
      <a href="index.html" style="display:inline-block;background:linear-gradient(135deg,var(--accent),#0284c7);color:white;padding:12px 28px;border-radius:8px;text-decoration:none;font-weight:600;transition:all 0.3s ease;">üè† Volver al inicio</a>
    </div>
  </main>

  <footer class="site-footer">
    <p>¬© P√°gina web POO 2026 - Programaci√≥n Orientada a Objetos</p>
    <p>Kevin Zapata - Todos los derechos reservados</p>
    <p>Educaci√≥n Superior TSUDS - ITECSUR</p>
  </footer>
  
  <!-- Botones de navegaci√≥n profesional -->
  <div class="nav-buttons-container">
    <button class="nav-button top" data-tooltip="Ir al principio" onclick="scrollToTop()">‚Üë</button>
    <button class="nav-button" data-tooltip="Subir p√°gina" onclick="scrollUp()">‚Üë</button>
    <button class="nav-button" data-tooltip="Bajar p√°gina" onclick="scrollDown()">‚Üì</button>
    <button class="nav-button bottom" data-tooltip="Ir al final" onclick="scrollToBottom()">‚Üì</button>
  </div>
  
  <script src="js/main.js"></script>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    
    function scrollUp() {
      window.scrollBy({ top: -window.innerHeight * 0.8, behavior: 'smooth' });
    }
    
    function scrollDown() {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
    }
  </script>
</body>
</html>
