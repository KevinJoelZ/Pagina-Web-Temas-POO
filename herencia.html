<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Herencia en POO - POO</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <header class="site-header">
    <nav class="navbar">
      <div class="brand"><a href="index.html">POO</a></div>
      <ul class="nav-links">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="fundamentos.html">Fundamentos</a></li>
        <li><a href="instanciacion.html">Instanciación</a></li>
        <li><a href="herencia.html">Herencia</a></li>
        <li><a href="ejercicios.html">Ejercicios</a></li>
        <li><a href="ejercicios-en-clase.html">Ejercicios en Clase</a></li>
      </ul>
    </nav>
  </header>

  <main class="content">
    <h1>Conceptos Fundamentales de Herencia en POO</h1>

    <p>La herencia es uno de los pilares de la Programación Orientada a Objetos. Permite que una clase herede atributos y métodos de otra, promoviendo reutilización de código, extensibilidad y creación de jerarquías bien estructuradas. En esta página aprenderás cómo funcionan las relaciones "es-un" entre clases.</p>

    <section id="que-es-herencia">
      <h2>¿Qué es la Herencia?</h2>
      <p><strong>Definición:</strong> La herencia es un mecanismo que permite que una clase (subclase o clase derivada) herede atributos y métodos de otra clase (superclase o clase base). La subclase extiende la funcionalidad de la superclase y puede agregar nuevos atributos y métodos, así como sobrescribir métodos existentes.</p>

      <h3>Relación "es-un"</h3>
      <p>La herencia modelar una relación "es-un". Por ejemplo: un <strong>Empleado es-un Persona</strong>, un <strong>Auto es-un Vehículo</strong>. Esta relación indica que la subclase es un tipo especial de la superclase, heredando todas sus características.</p>

      <div class="figure">
        <svg class="svg-illustration" viewBox="0 0 700 250" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Herencia - Superclase y Subclases">
          <rect x="250" y="20" width="200" height="80" rx="10" fill="#eef6ff" stroke="#0369a1" stroke-width="2"/>
          <text x="270" y="50" font-size="16" font-weight="700" fill="#0f1724">Persona (Superclase)</text>
          <text x="270" y="70" font-size="12" fill="#374151">nombre, edad</text>
          <text x="270" y="85" font-size="12" fill="#374151">saludar(), trabajar()</text>

          <rect x="50" y="150" width="180" height="80" rx="10" fill="#fff7ed" stroke="#d97706" stroke-width="2"/>
          <text x="70" y="180" font-size="14" font-weight="700" fill="#0f1724">Empleado</text>
          <text x="70" y="200" font-size="12" fill="#374151">+ salario, puesto</text>
          <text x="70" y="215" font-size="12" fill="#374151">+ calcularBono()</text>

          <rect x="310" y="150" width="180" height="80" rx="10" fill="#f0fdf4" stroke="#059669" stroke-width="2"/>
          <text x="330" y="180" font-size="14" font-weight="700" fill="#0f1724">Estudiante</text>
          <text x="330" y="200" font-size="12" fill="#374151">+ matricula, promedio</text>
          <text x="330" y="215" font-size="12" fill="#374151">+ estudiar()</text>

          <rect x="570" y="150" width="180" height="80" rx="10" fill="#faf5ff" stroke="#7c3aed" stroke-width="2"/>
          <text x="590" y="180" font-size="14" font-weight="700" fill="#0f1724">Doctor</text>
          <text x="590" y="200" font-size="12" fill="#374151">+ especialidad, licencia</text>
          <text x="590" y="215" font-size="12" fill="#374151">+ diagnosticar()</text>

          <path d="M350 100 L140 150" stroke="#374151" stroke-width="2" stroke-dasharray="5 5" marker-end="url(#arrowhead2)"/>
          <path d="M350 100 L400 150" stroke="#374151" stroke-width="2" stroke-dasharray="5 5" marker-end="url(#arrowhead2)"/>
          <path d="M370 100 L660 150" stroke="#374151" stroke-width="2" stroke-dasharray="5 5" marker-end="url(#arrowhead2)"/>

          <defs>
            <marker id="arrowhead2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#374151"/>
            </marker>
          </defs>

          <text x="200" y="125" font-size="11" fill="#6b7280" font-style="italic">extiende</text>
          <text x="360" y="125" font-size="11" fill="#6b7280" font-style="italic">extiende</text>
          <text x="500" y="125" font-size="11" fill="#6b7280" font-style="italic">extiende</text>
        </svg>
      </div>

      <h3>Conceptos Básicos de Herencia</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Superclase (Clase Base)</h4>
          <p>Clase de la que otras heredan. Define atributos y métodos comunes. Ejemplo: <code>Persona</code> es la superclase de <code>Empleado</code>, <code>Estudiante</code> y <code>Doctor</code>. Proporciona la estructura general y comportamiento compartido.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Subclase (Clase Derivada)</h4>
          <p>Clase que hereda de otra. Reutiliza código de la superclase y agrega funcionalidad específica. Ejemplo: <code>Empleado</code> hereda de <code>Persona</code> y agrega atributos como <code>salario</code>. Usa palabra clave <code>extends</code>.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Herencia Simple vs Múltiple</h4>
          <p><strong>Java soporta herencia simple:</strong> una clase extiende solo una superclase. <strong>Herencia múltiple:</strong> no permitida en Java (para evitar ambigüedades), pero se logra mediante interfaces. En Java: <code>class Subclase extends Superclase</code>.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Reutilización de Código</h4>
          <p>No repites código: si <code>Persona</code> tiene método <code>saludar()</code>, todos sus subclases lo heredan automáticamente. Esto reduce duplicación, facilita mantenimiento y asegura consistencia en toda la jerarquía.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Extensibilidad</h4>
          <p>Puedes agregar nuevos métodos y atributos en subclases sin modificar la superclase. Facilita la evolución del código: nuevas subclases pueden crearse según cambien los requerimientos sin afectar código existente.</p>
        </div>
      </div>
    </section>

    <section id="sintaxis-herencia">
      <h2>Sintaxis de Herencia en Java</h2>
      <p>La herencia en Java se declara con la palabra clave <code>extends</code>. Una clase que hereda extiende una superclase y obtiene acceso a todos sus miembros públicos y protegidos.</p>

      <h3>Estructura Básica</h3>
      <p><strong>Explicación:</strong> Esta es la estructura básica de herencia. <code>Persona</code> es la superclase que define atributos y métodos comunes. <code>Empleado</code> extiende <code>Persona</code> usando <code>extends</code>, heredando automáticamente todos sus miembros. El constructor de <code>Empleado</code> debe llamar a <code>super()</code> para inicializar la superclase.</p>
      <pre><code class="language-java">// Superclase: define los datos y comportamientos comunes
public class Persona {
    // Atributo private: no heredable, solo accesible a través de métodos
    private String nombre;
    // Atributo private: no heredable
    private int edad;

    // Constructor: inicializa los atributos de Persona
    public Persona(String nombre, int edad) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
    }

    // Getter: retorna el nombre (heredable, accesible en subclases)
    public String getNombre() { return nombre; }
    // Getter: retorna la edad (heredable, accesible en subclases)
    public int getEdad() { return edad; }

    // Método concreto: todas las subclases lo heredan
    public void saludar() {
        // Imprime un saludo usando el nombre de la persona
        System.out.println("Hola, soy " + nombre);
    }
}

// Subclase: extiende Persona usando la palabra clave extends
public class Empleado extends Persona {
    // Atributo private: específico de Empleado
    private double salario;
    // Atributo private: específico de Empleado
    private String puesto;

    // Constructor de Empleado: recibe parámetros de Persona + parámetros propios
    public Empleado(String nombre, int edad, double salario, String puesto) {
        // Llama OBLIGATORIAMENTE al constructor de la superclase (Persona) como primera línea
        // super() inicializa los atributos heredados (nombre, edad)
        super(nombre, edad);
        // Asigna el salario específico de Empleado
        this.salario = salario;
        // Asigna el puesto específico de Empleado
        this.puesto = puesto;
    }

    // Getter: retorna el salario
    public double getSalario() { return salario; }
    // Getter: retorna el puesto
    public String getPuesto() { return puesto; }

    // Método nuevo en Empleado: no existía en Persona
    public double calcularBono() {
        // Calcula y retorna el 10% del salario como bonus
        return salario * 0.10;
    }
}
</code></pre>

      <h3>Elementos Clave en la Sintaxis</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Palabra Clave extends</h4>
          <p>Sintaxis: <code>public class Subclase extends Superclase { ... }</code>. Indica que <code>Subclase</code> hereda de <code>Superclase</code>. Java permite una sola superclase por clase. Define relación "es-un".</p>
        </div>
        <div class="card-profesional-green">
          <h4>Palabra Clave super</h4>
          <p>Referencia a la superclase. Úsala para: 1) Llamar constructor de superclase: <code>super(parámetros)</code>. 2) Acceder métodos de superclase: <code>super.método()</code>. 3) Acceder atributos: <code>super.atributo</code>. Debes usar <code>super()</code> como primera línea en constructor de subclase.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Accesibilidad: private vs protected</h4>
          <p><code>private</code>: solo la clase, NO heredable. <code>protected</code>: la clase, subclases y mismo paquete, SÍ heredable. <code>public</code>: heredable desde cualquier lugar. <code>default</code>: heredable solo en mismo paquete. Para herencia, prefiere <code>protected</code> en superclases.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Modificador final</h4>
          <p><code>final</code> en clase: no puede ser extendida. <code>final</code> en método: no puede ser sobrescrito. <code>final</code> en atributo: no puede cambiar. Usa <code>final</code> cuando NO quieras que se hereden o modifiquen. Ejemplo: <code>String</code> en Java es final.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Constructor en Herencia</h4>
          <p>Subclases NO heredan constructores automáticamente. Debes definir tu propio constructor en subclase y llamar <code>super(parámetros)</code> para inicializar la superclase. Si superclase tiene constructor sin parámetros, Java llama automáticamente.</p>
        </div>
      </div>

      <h3>Ejemplo Completo: Jerarquía de Vehículos</h3>
      <p><strong>Explicación:</strong> Este ejemplo muestra una jerarquía de tres niveles. <code>Vehículo</code> es la superclase base. <code>Auto</code> y <code>Moto</code> son subclases que heredan de <code>Vehículo</code> y agregan atributos/métodos específicos. Demuestra cómo reutilizar código y especializar comportamiento.</p>
      <pre><code class="language-java">// Superclase: define los datos y comportamientos comunes de todos los vehículos
public class Vehículo {
    // Atributo private: marca del vehículo
    private String marca;
    // Atributo private: modelo del vehículo
    private String modelo;
    // Atributo private: año de fabricación
    private int año;

    // Constructor: inicializa un vehículo con marca, modelo y año
    public Vehículo(String marca, String modelo, int año) {
        // Asigna la marca
        this.marca = marca;
        // Asigna el modelo
        this.modelo = modelo;
        // Asigna el año
        this.año = año;
    }

    // Método concreto: muestra información del vehículo (heredable)
    public void mostrarInfo() {
        // Imprime marca, modelo y año formateado
        System.out.println(marca + " " + modelo + " (" + año + ")");
    }

    // Método concreto: acción de arrancar (heredable por todas las subclases)
    public void arrancar() {
        // Imprime mensaje genérico de arranque
        System.out.println("El vehículo está arrancando...");
    }
}

// Subclase 1: Auto extiende Vehículo
public class Auto extends Vehículo {
    // Atributo private: número de puertas del auto
    private int puertas;

    // Constructor: recibe parámetros de Vehículo + parámetros de Auto
    public Auto(String marca, String modelo, int año, int puertas) {
        // Llama al constructor de Vehículo (superclase) con sus parámetros
        super(marca, modelo, año);
        // Asigna el número de puertas específico de Auto
        this.puertas = puertas;
    }

    // Getter: retorna el número de puertas
    public int getPuertas() { return puertas; }

    // Método nuevo específico de Auto: no existe en Vehículo
    public void abrirMaletero() {
        // Imprime que se abre el maletero
        System.out.println("Maletero del auto abierto");
    }
}

// Subclase 2: Moto extiende Vehículo
public class Moto extends Vehículo {
    // Atributo private: booleano que indica si la moto tiene sidecar
    private boolean tieneSidecar;

    // Constructor: recibe parámetros de Vehículo + parámetros de Moto
    public Moto(String marca, String modelo, int año, boolean tieneSidecar) {
        // Llama al constructor de Vehículo (superclase) con sus parámetros
        super(marca, modelo, año);
        // Asigna si tiene sidecar
        this.tieneSidecar = tieneSidecar;
    }

    // Getter: retorna si la moto tiene sidecar
    public boolean tieneSidecar() { return tieneSidecar; }

    // Método nuevo específico de Moto: no existe en Vehículo
    public void hacerCaballito() {
        // Imprime acción característica de motos
        System.out.println("¡La moto está haciendo caballito!");
    }
}

// Clase de uso: demuestra la herencia en acción
public class Main {
    // Método main: punto de entrada del programa
    public static void main(String[] args) {
        // Crea una instancia de Auto
        Auto auto = new Auto("Toyota", "Corolla", 2023, 4);
        // Llama método heredado de Vehículo
        auto.mostrarInfo();    // Heredado de Vehículo - imprime: Toyota Corolla (2023)
        // Llama otro método heredado de Vehículo
        auto.arrancar();       // Heredado de Vehículo - imprime: El vehículo está arrancando...
        // Llama método específico de Auto
        auto.abrirMaletero();  // Método de Auto - imprime: Maletero del auto abierto

        // Crea una instancia de Moto
        Moto moto = new Moto("Honda", "CB500", 2022, false);
        // Llama método heredado de Vehículo
        moto.mostrarInfo();    // Heredado de Vehículo - imprime: Honda CB500 (2022)
        // Llama método específico de Moto
        moto.hacerCaballito(); // Método de Moto - imprime: ¡La moto está haciendo caballito!
    }
}
</code></pre>
    </section>

    <section id="sobrescritura-metodos">
      <h2>Sobrescritura (Override) de Métodos</h2>
      <p>La sobrescritura permite que una subclase proporcione su propia implementación de un método heredado. El método de la subclase reemplaza el de la superclase cuando se invoca en un objeto de la subclase. Es fundamental para polimorfismo.</p>

      <h3>Principios de Sobrescritura</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Override Annotation</h4>
          <p>Usa <code>@Override</code> para indicar que sobrescribes un método. No es obligatorio pero es buena práctica. El compilador verifica que el método existe en la superclase. Si cometes error en la firma, el compilador lo detecta.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Firma Idéntica</h4>
          <p>El método sobrescrito debe tener exactamente la misma firma: mismo nombre, mismos parámetros, mismo tipo de retorno. Si cambias la firma, NO es sobrescritura, es sobrecarga (otro concepto). La firma debe ser idéntica para que el polimorfismo funcione.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Acceso Más Permisivo</h4>
          <p>El modificador de acceso del método sobrescrito debe ser igual o más permisivo. Ejemplo: si superclase tiene <code>protected</code>, subclase puede tener <code>protected</code> o <code>public</code>, pero NO <code>private</code>. Garantiza que subclases no restrinjan acceso.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>No Cambiar Tipo de Retorno</h4>
          <p>El tipo de retorno debe ser idéntico o covariant (subtipo del tipo original). Java permite que retornes un subtipo del retorno original. Ejemplo: si superclase retorna <code>Persona</code>, subclase puede retornar <code>Empleado</code> (si Empleado extiende Persona).</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Excepciones Lanzadas</h4>
          <p>El método sobrescrito puede lanzar excepciones iguales o más específicas (subtipos) que el método de la superclase. No puedes lanzar excepciones más generales. Esto asegura compatibilidad: código que usa el método no se sorprende con excepciones inesperadas.</p>
        </div>
      </div>

      <h3>Ejemplo: Sobrescritura en Acción</h3>
      <p><strong>Explicación:</strong> Este ejemplo demuestra polimorfismo mediante sobrescritura. La superclase <code>Animal</code> define un método <code>hacerSonido()</code> genérico. Las subclases <code>Perro</code> y <code>Gato</code> sobrescriben este método con su propio comportamiento. Cuando se invoca <code>hacerSonido()</code> en tiempo de ejecución, se ejecuta la versión específica de cada clase.</p>
      <pre><code class="language-java">// Superclase: define el comportamiento común
public class Animal {
    // Atributo private: nombre del animal
    private String nombre;

    // Constructor: inicializa el animal con un nombre
    public Animal(String nombre) {
        // Asigna el nombre
        this.nombre = nombre;
    }

    // Getter: retorna el nombre
    public String getNombre() { return nombre; }

    // Método concreto: versión genérica (será sobrescrita en subclases)
    public void hacerSonido() {
        // Mensaje genérico de sonido
        System.out.println("El animal hace un sonido genérico");
    }
}

// Subclase 1: Perro extiende Animal
public class Perro extends Animal {
    // Constructor: recibe el nombre y lo pasa a la superclase
    public Perro(String nombre) {
        // Llama al constructor de Animal con el nombre
        super(nombre);
    }

    // Sobrescritura: proporciona implementación específica de hacerSonido para Perro
    // @Override indica que sobrescribimos un método de la superclase
    @Override
    public void hacerSonido() {
        // Imprime el sonido específico de un perro usando el nombre heredado
        System.out.println(getNombre() + " ladra: ¡guau guau!");
    }
}

// Subclase 2: Gato extiende Animal
public class Gato extends Animal {
    // Constructor: recibe el nombre y lo pasa a la superclase
    public Gato(String nombre) {
        // Llama al constructor de Animal con el nombre
        super(nombre);
    }

    // Sobrescritura: proporciona implementación específica de hacerSonido para Gato
    @Override
    public void hacerSonido() {
        // Imprime el sonido específico de un gato
        System.out.println(getNombre() + " maúlla: ¡miau!");
    }
}

// Clase de uso: demuestra el polimorfismo en acción
public class Main {
    // Método main: punto de entrada
    public static void main(String[] args) {
        // Crea referencia de tipo Animal pero objeto Perro (polimorfismo)
        Animal perro = new Perro("Max");
        // Crea referencia de tipo Animal pero objeto Gato (polimorfismo)
        Animal gato = new Gato("Misi");

        // Invoca hacerSonido() en el perro
        // En tiempo de ejecución, invoca el método sobrescrito de Perro
        perro.hacerSonido();  // Salida: Max ladra: ¡guau guau!
        
        // Invoca hacerSonido() en el gato
        // En tiempo de ejecución, invoca el método sobrescrito de Gato
        gato.hacerSonido();   // Salida: Misi maúlla: ¡miau!
        
        // Ambos son Animal, pero cada uno se comporta diferente
        // El método invocado depende del tipo real del objeto en tiempo de ejecución
    }
}
</code></pre>
    </section>

    <section id="polimorfismo">
      <h2>Polimorfismo mediante Herencia</h2>
      <p>Polimorfismo significa "muchas formas". En el contexto de herencia, permite que objetos de diferentes subclases respondan al mismo mensaje (método) de manera diferente. Es una consecuencia poderosa de la herencia y sobrescritura de métodos.</p>

      <h3>Tipos y Beneficios del Polimorfismo</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Polimorfismo de Compilación (Sobrecarga)</h4>
          <p>Múltiples métodos con el mismo nombre pero diferentes parámetros. El compilador elige cuál invocar según los argumentos. Ocurre en tiempo de compilación. Ejemplo: <code>System.out.println()</code> acepta int, String, double, etc.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Polimorfismo de Ejecución (Sobrescritura)</h4>
          <p>Método invocado en tiempo de ejecución según el tipo real del objeto, NO el tipo de la variable. Requiere herencia y sobrescritura. Ejemplo: <code>Animal a = new Perro()</code>; <code>a.hacerSonido()</code> invoca el método de Perro, no el de Animal.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Referencia Superclase, Objeto Subclase</h4>
          <p>Puedes asignar objeto de subclase a variable de tipo superclase: <code>Persona p = new Empleado(...)</code>. La variable <code>p</code> ve solo miembros de Persona, pero invoca métodos del Empleado real. Fundamental para diseño flexible.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Beneficios del Polimorfismo</h4>
          <p><strong>1) Flexibilidad:</strong> Código genérico funciona con múltiples tipos. <strong>2) Extensibilidad:</strong> Agregar nuevas subclases sin cambiar código existente. <strong>3) Mantenibilidad:</strong> Menos duplicación, cambios en un lugar. <strong>4) Reusabilidad:</strong> Métodos genéricos reutilizables.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Ejemplo: Colecciones Polimórficas</h4>
          <p>Puedes almacenar diferentes subclases en un contenedor de la superclase: <code>List&lt;Animal&gt; animales = new ArrayList&lt;&gt;()</code>; <code>animales.add(new Perro(...))</code>; <code>animales.add(new Gato(...))</code>. Itera y invoca métodos: cada objeto responde apropiadamente.</p>
        </div>
      </div>

      <h3>Ejemplo Completo: Gestión de Empleados</h3>
      <p><strong>Explicación:</strong> Este es un ejemplo completo que demuestra polimorfismo en un contexto real. <code>Empleado</code> es una clase abstracta que define el contrato. Las subclases (EmpleadoOficina, Vendedor) implementan <code>calcularBonus()</code> diferente. La clase <code>GestorEmpleados</code> demuestra polimorfismo: trabaja con referencias de <code>Empleado</code> pero ejecuta métodos específicos de cada subclase.</p>
      <pre><code class="language-java">// Importar ArrayList y List
import java.util.ArrayList;
import java.util.List;

// Superclase abstracta: define el contrato que todas las subclases deben cumplir
public abstract class Empleado {
    // Atributo protected: heredable por subclases
    protected String nombre;
    // Atributo protected: heredable por subclases
    protected double salario;

    // Constructor: inicializa nombre y salario
    public Empleado(String nombre, double salario) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna el salario
        this.salario = salario;
    }

    // Método abstracto: cada subclase debe implementarlo
    public abstract double calcularBonus();

    // Sobrescribe toString para representación legible
    @Override
    public String toString() {
        // Retorna nombre, salario formateado
        return nombre + " - Salario: $" + salario;
    }
}

// Subclase 1: EmpleadoOficina
public class EmpleadoOficina extends Empleado {
    // Atributo private: horas extra trabajadas
    private int horasExtra;

    // Constructor: recibe parámetros de Empleado + horasExtra
    public EmpleadoOficina(String nombre, double salario, int horasExtra) {
        // Llama constructor de Empleado
        super(nombre, salario);
        // Asigna horas extra
        this.horasExtra = horasExtra;
    }

    // Implementación específica de calcularBonus para oficina
    @Override
    public double calcularBonus() {
        // Retorna 15% del salario + $50 por cada hora extra
        return salario * 0.15 + (horasExtra * 50);
    }
}

// Subclase 2: Vendedor
public class Vendedor extends Empleado {
    // Atributo private: total de ventas realizadas
    private double ventasRealizadas;

    // Constructor: recibe parámetros de Empleado + ventasRealizadas
    public Vendedor(String nombre, double salario, double ventasRealizadas) {
        // Llama constructor de Empleado
        super(nombre, salario);
        // Asigna ventas realizadas
        this.ventasRealizadas = ventasRealizadas;
    }

    // Implementación específica de calcularBonus para vendedores
    @Override
    public double calcularBonus() {
        // Retorna 5% de comisión sobre las ventas realizadas
        return ventasRealizadas * 0.05; // 5% de comisión
    }
}

// Clase que gestiona empleados de forma polimórfica
public class GestorEmpleados {
    // Lista que almacena referencias de tipo Empleado (puede contener cualquier subclase)
    private List&lt;Empleado&gt; empleados = new ArrayList&lt;&gt;();

    // Método para agregar un empleado (de cualquier tipo) a la lista
    public void agregarEmpleado(Empleado e) {
        // Agrega el empleado a la lista (puede ser EmpleadoOficina, Vendedor, etc)
        empleados.add(e);
    }

    // Método que muestra bonus de todos los empleados (polimórfico)
    public void mostrarBonus() {
        // Itera sobre cada empleado en la lista
        for (Empleado e : empleados) {
            // Imprime empleado y su bonus
            // calcularBonus() se invoca polimórficamente: cada tipo ejecuta su versión
            System.out.println(e + " - Bonus: $" + e.calcularBonus());
        }
    }
}

// Clase de uso: demuestra el sistema en acción
public class Main {
    // Método main: punto de entrada
    public static void main(String[] args) {
        // Crea instancia del gestor
        GestorEmpleados gestor = new GestorEmpleados();

        // Crea y agrega un EmpleadoOficina
        // Agrupa nombre, salario, horasExtra
        gestor.agregarEmpleado(new EmpleadoOficina("Ana", 2000, 10));
        
        // Crea y agrega un Vendedor
        // Agrupa nombre, salario, ventasRealizadas
        gestor.agregarEmpleado(new Vendedor("Carlos", 1500, 5000));

        // Muestra bonus de todos los empleados
        // El gestor no conoce tipos específicos, pero cada uno calcula bonus correcto
        gestor.mostrarBonus();
        // Salida esperada:
        // Ana - Salario: $2000.0 - Bonus: $500.0
        // Carlos - Salario: $1500.0 - Bonus: $250.0
    }
}
</code></pre>
    </section>

    <section id="modificadores-acceso">
      <h2>Modificadores de Acceso en Herencia</h2>
      <p>Los modificadores de acceso (<code>private</code>, <code>protected</code>, <code>public</code>, default) controlan qué miembros de una clase son accesibles en subclases. Entender esto es crucial para un buen diseño de jerarquías de herencia.</p>

      <h3>Modificadores de Acceso Explicados</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>private (Privado)</h4>
          <p>Acceso <strong>solo en la clase.</strong> <strong>NO heredable.</strong> Subclases NO pueden acceder directamente. Para acceder, debe ir a través de métodos públicos/protegidos. Proporciona máxima encapsulación. Ejemplo: detalles internos de implementación.</p>
        </div>
        <div class="card-profesional-green">
          <h4>protected (Protegido)</h4>
          <p>Acceso en: la clase, subclases, mismo paquete. <strong>SÍ heredable.</strong> Ideal para members que quieres que hereden subclases pero no sean públicos. Menos restrictivo que private. Úsalo en superclases para datos/métodos que subclases necesitan.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>public (Público)</h4>
          <p>Acceso <strong>desde cualquier lugar.</strong> <strong>SÍ heredable.</strong> Parte de la interfaz pública de la clase. Úsalo para métodos de API que todas las clases usan. Menos restrictivo. Cambios pueden afectar mucho código externo.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>default (Sin modificador)</h4>
          <p>Acceso en la clase y <strong>mismo paquete.</strong> <strong>SÍ heredable dentro del paquete.</strong> Si subclase está en otro paquete, NO hereda. Útil para miembros que son internos al paquete pero no públicos globalmente.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Tabla de Acceso en Herencia</h4>
          <p><code>private</code>: ❌ NO heredable. <code>protected</code>: ✅ Heredable. <code>public</code>: ✅ Heredable. <code>default</code>: ✅ Heredable (mismo paquete solo). Regla: prefiere el nivel de acceso más restrictivo posible para maximizar seguridad.</p>
        </div>
      </div>

      <h3>Ejemplo: Modificadores en Jerarquía</h3>
      <p><strong>Explicación:</strong> Este ejemplo muestra cómo funcionan los diferentes modificadores de acceso en una jerarquía de herencia. <code>private</code> NO es heredable, <code>protected</code> es heredable, <code>public</code> es heredable. La clase <code>Empleado</code> intenta acceder a diferentes miembros de <code>Persona</code>.</p>
      <pre><code class="language-java">// Superclase con diferentes modificadores de acceso
public class Persona {
    // Atributo private: NO heredable, solo accesible dentro de Persona
    private String numeroDocumento;
    
    // Atributo protected: heredable, accesible en subclases
    protected String nombre;
    
    // Atributo public: heredable, accesible desde cualquier lugar
    public int edad;
    
    // Atributo default (sin modificador): heredable solo en mismo paquete
    int id;

    // Método protected: heredable, implementación puede ser de subclases
    protected void saludar() {
        // Imprime saludo
        System.out.println("Hola");
    }

    // Método private: NO heredable, solo accesible dentro de Persona
    private void detallePersonal() {
        // Imprime detalles personales
        System.out.println("Este es privado");
    }
}

// Subclase que intenta acceder a miembros de Persona
public class Empleado extends Persona {
    // Método que intenta acceder a miembros heredados
    public void mostrarDatos() {
        // ✅ OK - protected: heredable y accesible en subclases
        System.out.println(nombre);              // Acceso permitido
        
        // ✅ OK - public: heredable y accesible desde cualquier lugar
        System.out.println(edad);                // Acceso permitido
        
        // ❌ ERROR - private: NO heredable, no accesible en subclases
        // System.out.println(numeroDocumento);  // COMPILARÍA ERROR
        
        // ✅ OK - protected: heredable, puede llamarse método heredado
        saludar();                               // Acceso permitido
        
        // ❌ ERROR - private: NO heredable, no accesible en subclases
        // detallePersonal();                    // COMPILARÍA ERROR
    }
}
</code></pre>
    </section>

    <section id="ejercicios">
      <h2>Ejercicios Prácticos</h2>

      <h3>Ejercicio 1: Jerarquía de Figuras Geométricas</h3>
      <p><strong>Enunciado:</strong> Crea una superclase abstracta <code>Figura</code> con métodos abstractos <code>calcularArea()</code> y <code>calcularPerimetro()</code>. Implementa <code>Rectángulo</code> y <code>Círculo</code>.</p>

      <div class="solution">
        <pre><code class="language-java">// Superclase abstracta
abstract class Figura {
    protected String nombre;
    public Figura(String nombre) { this.nombre = nombre; }
    
    // Métodos abstractos - cada subclase implementa
    public abstract double calcularArea();
    public abstract double calcularPerimetro();
    
    @Override
    public String toString() { return nombre; }
}

// Subclase 1: Rectángulo
class Rectangulo extends Figura {
    private double ancho, alto;
    public Rectangulo(double ancho, double alto) {
        super("Rectángulo");
        this.ancho = ancho;
        this.alto = alto;
    }
    
    @Override
    public double calcularArea() { return ancho * alto; }
    
    @Override
    public double calcularPerimetro() { return 2 * (ancho + alto); }
}

// Subclase 2: Círculo
class Circulo extends Figura {
    private double radio;
    public Circulo(double radio) {
        super("Círculo");
        this.radio = radio;
    }
    
    @Override
    public double calcularArea() { return Math.PI * radio * radio; }
    
    @Override
    public double calcularPerimetro() { return 2 * Math.PI * radio; }
}

// Programa principal
public class Main {
    public static void main(String[] args) {
        // Polimorfismo: lista de Figuras puede contener cualquier subclase
        Figura[] figuras = {
            new Rectangulo(5, 3),
            new Circulo(4)
        };
        
        // Iterar sobre figuras - cada una responde apropiadamente
        for (Figura f : figuras) {
            System.out.println(f + " - Área: " + String.format("%.2f", f.calcularArea()) + 
                             " - Perímetro: " + String.format("%.2f", f.calcularPerimetro()));
        }
    }
}
</code></pre>
      </div>

      <h3>Ejercicio 2: Sistema Bancario con Herencia</h3>
      <p><strong>Enunciado:</strong> Superclase abstracta <code>CuentaBancaria</code> con <code>depositar()</code>, <code>retirar()</code> y <code>calcularInteres()</code>. Subclases: <code>CuentaAhorro</code> (5% interés) y <code>CuentaCorriente</code> (sin interés, permite descubierto).</p>

      <div class="solution">
        <pre><code class="language-java">// Superclase abstracta
abstract class CuentaBancaria {
    protected String numero, titular;
    protected double saldo;
    
    public CuentaBancaria(String numero, String titular, double saldo) {
        this.numero = numero;
        this.titular = titular;
        this.saldo = saldo;
    }
    
    // Método concreto: todas las cuentas lo heredan
    public void depositar(double monto) {
        if (monto > 0) saldo += monto;
    }
    
    // Métodos abstractos: cada subclase implementa diferente
    public abstract boolean retirar(double monto);
    public abstract double calcularInteres();
    
    public double getSaldo() { return saldo; }
    
    @Override
    public String toString() { return titular + " - Saldo: $" + saldo; }
}

// Subclase 1: Cuenta de Ahorro - 5% interés, no permite descubierto
class CuentaAhorro extends CuentaBancaria {
    public CuentaAhorro(String numero, String titular, double saldo) {
        super(numero, titular, saldo);
    }
    
    @Override
    public boolean retirar(double monto) {
        if (monto > 0 && monto <= saldo) {
            saldo -= monto;
            return true;
        }
        return false;
    }
    
    @Override
    public double calcularInteres() { return saldo * 0.05; } // 5% anual
}

// Subclase 2: Cuenta Corriente - sin interés, permite descubierto
class CuentaCorriente extends CuentaBancaria {
    private double limite = 500; // Permite hasta $500 de descubierto
    
    public CuentaCorriente(String numero, String titular, double saldo) {
        super(numero, titular, saldo);
    }
    
    @Override
    public boolean retirar(double monto) {
        if (monto > 0 && monto <= (saldo + limite)) {
            saldo -= monto;
            return true;
        }
        return false;
    }
    
    @Override
    public double calcularInteres() { return 0; } // Sin interés
}

// Programa principal
public class Main {
    public static void main(String[] args) {
        CuentaBancaria c1 = new CuentaAhorro("001", "Ana", 1000);
        CuentaBancaria c2 = new CuentaCorriente("002", "Carlos", 500);
        
        // Depósitos
        c1.depositar(200);
        c2.depositar(300);
        
        // Retiros
        c1.retirar(100);
        c2.retirar(100);
        
        // Mostrar información con polimorfismo
        System.out.println(c1 + " - Interés: $" + String.format("%.2f", c1.calcularInteres()));
        System.out.println(c2 + " - Interés: $" + String.format("%.2f", c2.calcularInteres()));
    }
}
</code></pre>
      </div>
    </section>

    <h3>Cards de Refuerzo: Herencia</h3>
    <div class="cards-grid-teoricos">
      <div class="card-teorico">
        <h4>Herencia: Reutilización</h4>
        <p>Evita repetición de código compartiendo estructura entre clases relacionadas. Cambia en un lugar, afecta a todas las subclases. Menos bugs, más mantenible.</p>
      </div>
      <div class="card-teorico">
        <h4>extends: Una Superclase</h4>
        <p>Java permite una sola superclase por clase. Una subclase hereda de exactamente una clase. Crea jerarquías simples, fáciles de seguir y entender.</p>
      </div>
      <div class="card-teorico">
        <h4>super: Conexión a Superclase</h4>
        <p>Referencia a miembros de la superclase. Llama constructor de superclase en primera línea de constructor de subclase. Accede métodos sobrescritos si necesitas.</p>
      </div>
      <div class="card-teorico">
        <h4>@Override: Sobrescritura Explícita</h4>
        <p>Anotación que indica intención de sobrescribir. Compilador verifica la firma. Si cometes error, el compilador lo detecta. Buena práctica de código claro.</p>
      </div>
      <div class="card-teorico">
        <h4>Polimorfismo: Muchas Formas</h4>
        <p>Código genérico con referencias de superclase trabaja con múltiples subclases. Cada objeto responde apropiadamente según su tipo real. Flexible y extensible.</p>
      </div>
      <div class="card-teorico">
        <h4>protected: Para Subclases</h4>
        <p>Miembros protected son heredables. Usa en superclases para datos que subclases necesitan acceder directamente, pero que no deben ser públicos.</p>
      </div>
    </div>

    <h3>Buenas Prácticas en Herencia</h3>
    <div class="info-box">
      <ol>
        <li><strong>Relación "es-un" auténtica:</strong> Solo hereda si existe relación verdadera. No fuerces herencia solo para reutilizar código; considera composición.</li>
        <li><strong>Evita jerarquías profundas:</strong> Mantén profundidad ≤ 3 niveles. Jerarquías profundas son complejas y difíciles de mantener.</li>
        <li><strong>Usa classes abstractas para definir contratos:</strong> Si una clase no debe instanciarse directamente, hazla <code>abstract</code>. Define métodos abstractos para obligar a subclases a implementarlos.</li>
        <li><strong>Preferir composición cuando sea apropiado:</strong> Si necesitas múltiples comportamientos, composición es más flexible que herencia múltiple (que Java no soporta).</li>
        <li><strong>Documenta la jerarquía:</strong> Deja clara la relación entre superclase y subclases. Especifica qué métodos heredan, cuáles se sobreescriben.</li>
        <li><strong>No violes el contrato de la superclase:</strong> Métodos sobrescritos deben mantener semántica compatible. No cambies comportamiento esperado de manera radical.</li>
        <li><strong>Usa final juiciosamente:</strong> Hazlo <code>final</code> si no quieres que se herede o si herede rompe contrato. Pero no lo hagas por defecto.</li>
      </ol>
    </div>

    <section id="videos-educativos">
      <h2>Videos Educativos</h2>
      <div class="videos-grid">
        <div class="video-container">
          <h3>74. Programación en Java - Herencia y POO</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/74. Programación en Java __ POO __ Herencia en POO.mp4" type="video/mp4">
              Tu navegador no soporta la reproducción de video. <a href="videos/74. Programación en Java __ POO __ Herencia en POO.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Aprende los conceptos fundamentales de la herencia en Java, cómo crear jerarquías de clases y aplicar los principios de la Programación Orientada a Objetos de manera efectiva.</p>
        </div>
      </div>
    </section>

    <p class="muted">Recursos adicionales: <a href="https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html" target="_blank" rel="noopener">Subclasses (Oracle)</a> • <a href="https://www.geeksforgeeks.org/inheritance-in-java/" target="_blank" rel="noopener">Inheritance in Java (GeeksforGeeks)</a></p>

    <p><a href="index.html">Volver al inicio</a></p>
  </main>

  <footer class="site-footer">
    <p>&copy; Página web POO 2026 - Todos los derechos reservados.</p>
  </footer>
  
  <!-- Botones de navegación profesional -->
  <div class="nav-buttons-container">
    <button class="nav-button top" data-tooltip="Ir al principio" onclick="scrollToTop()">↑</button>
    <button class="nav-button" data-tooltip="Subir página" onclick="scrollUp()">↑</button>
    <button class="nav-button" data-tooltip="Bajar página" onclick="scrollDown()">↓</button>
    <button class="nav-button bottom" data-tooltip="Ir al final" onclick="scrollToBottom()">↓</button>
  </div>
  
  <script src="js/main.js" defer></script>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    
    function scrollUp() {
      window.scrollBy({ top: -window.innerHeight * 0.8, behavior: 'smooth' });
    }
    
    function scrollDown() {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
    }
  </script>
</body>
</html>
