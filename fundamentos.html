<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Fundamentos - POO</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <header class="site-header">
    <nav class="navbar">
      <div class="brand"><a href="index.html">POO</a></div>
      <ul class="nav-links">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="fundamentos.html">Fundamentos</a></li>
        <li><a href="instanciacion.html">Instanciaci√≥n</a></li>
        <li><a href="herencia.html">Herencia</a></li>
        <li><a href="ejercicios.html">Ejercicios</a></li>
        <li><a href="ejercicios-en-clase.html">Ejercicios en Clase</a></li>
      </ul>
    </nav>
  </header>

  <main class="content">
    <h1>Fundamentos de la Programaci√≥n Orientada a Objetos</h1>

    <p>En esta p√°gina profundizaremos en <strong>Encapsulaci√≥n</strong> y <strong>Abstracci√≥n</strong>. Ver√°s definiciones formales, ventajas, buenas pr√°cticas en Java, diagramas ilustrativos y ejemplos pr√°cticos listos para ejecutar.</p>

    <section id="encapsulacion">
      <h2>Encapsulaci√≥n</h2>
      <p><strong>Definici√≥n:</strong> La encapsulaci√≥n es el mecanismo de <em>ocultar</em> los datos internos de una clase y exponer s√≥lo lo necesario mediante una interfaz p√∫blica. Esto protege la integridad del objeto y permite cambiar la implementaci√≥n interna sin afectar a los consumidores del objeto.</p>

      <h3>¬øPor qu√© es importante?</h3>
      <ul>
        <li>Protege invariantes del objeto (por ejemplo, que un saldo no sea negativo).</li>
        <li>Reduce el acoplamiento entre m√≥dulos.</li>
        <li>Permite validar y sanitizar datos en puntos controlados (setters o constructores).</li>
        <li>Facilita el mantenimiento y la evoluci√≥n del c√≥digo.</li>
      </ul>

      <div class="figure">
        <svg class="svg-illustration" viewBox="0 0 700 180" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Encapsulaci√≥n - diagrama">
          <rect x="6" y="6" width="688" height="168" rx="14" fill="#ffffff" stroke="#dceffd" />
          <text x="26" y="36" font-size="16" fill="#0f1724" font-weight="700">BankAccount (encapsulado)</text>
          <text x="40" y="66" font-size="13" fill="#374151">Campos privados: balance, owner</text>
          <text x="40" y="86" font-size="13" fill="#374151">M√©todos p√∫blicos: deposit(), withdraw(), getBalance()</text>
          <g>
            <rect x="480" y="46" width="176" height="86" rx="8" fill="#f1f9ff" stroke="#c8e4ff" />
            <text x="494" y="72" font-size="12" fill="#0f1724">API p√∫blica</text>
            <text x="494" y="92" font-size="12" fill="#374151">(lo que usan otras clases)</text>
          </g>
          <path d="M 420 80 L 480 80" stroke="#9aaed0" stroke-width="2" stroke-dasharray="6 4" />
          <text x="332" y="120" font-size="11" fill="#6b7280">Implementaci√≥n interna oculta</text>
        </svg>
      </div>

      <h3>Modificadores de acceso en Java</h3>
      <p>Usa <code>private</code> para datos internos; m√©todos p√∫blicos (<code>public</code>) para la interfaz; <code>protected</code> cuando quieras permitir acceso a subclases dentro del paquete; el modificador por defecto (package-private) restringe al paquete. Prefiere mantener el m√≠nimo acceso necesario.</p>

      <h3>Ejemplo pr√°ctico compilable (BankAccount)</h3>
      <p><strong>Explicaci√≥n:</strong> BankAccount demuestra encapsulaci√≥n: balance privado, m√©todos p√∫blicos controlan acceso. M√©todo privado hasSufficientFunds() es interno. Main ejecutable directo.</p>
      <pre><code class="language-java">// Clase BankAccount: demuestra encapsulaci√≥n efectiva
public class BankAccount {
    // Atributo private: solo accesible dentro de esta clase
    private double balance;
    // Atributo private final: no puede modificarse despu√©s de inicializar
    private final String owner;

    // Constructor: inicializa la cuenta con due√±o y saldo inicial
    public BankAccount(String owner, double initial) {
        // Asigna el nombre del due√±o
        this.owner = owner;
        // Asegura balance no negativo usando Math.max
        this.balance = Math.max(0, initial);
    }

    // Getter: retorna el nombre del due√±o
    public String getOwner() { return owner; }
    // Getter: retorna el saldo actual
    public double getBalance() { return balance; }

    // M√©todo p√∫blico: depositar dinero (incrementa balance si amount > 0)
    public void deposit(double amount) {
        // Valida que amount sea positivo antes de sumar
        if (amount > 0) balance += amount;
    }

    // M√©todo p√∫blico: retirar dinero (decrementa balance si hay fondos suficientes)
    public boolean withdraw(double amount) {
        // Verifica que amount sea positivo AND hay fondos suficientes
        if (amount > 0 && amount <= balance) {
            // Resta el amount del balance
            balance -= amount; 
            // Retorna true indicando retiro exitoso
            return true;
        }
        // Si no se puede retirar, retorna false
        return false;
    }

    // M√©todo private: solo usado internamente (no accesible desde fuera)
    private boolean hasSufficientFunds(double amount) { 
        // Retorna true si hay fondos suficientes
        return amount <= balance; 
    }

    // Main: m√©todo de entrada compilable en OnlineJava
    public static void main(String[] args) {
        // Crea una nueva cuenta de Juan P√©rez con saldo inicial $1000
        BankAccount account = new BankAccount("Juan P√©rez", 1000);
        // Imprime informaci√≥n inicial de la cuenta
        System.out.println("Cuenta: " + account.getOwner() + " | Balance: $" + account.getBalance());
        
        // Realiza un dep√≥sito de $500
        account.deposit(500);
        // Imprime nuevo balance despu√©s del dep√≥sito
        System.out.println("Despu√©s de depositar: $" + account.getBalance());
        
        // Realiza un retiro de $200 (guarda resultado en variable)
        boolean retiro = account.withdraw(200);
        // Imprime resultado del retiro y nuevo balance
        System.out.println("Retiro exitoso: " + retiro + " | Balance: $" + account.getBalance());
    }
}
</code></pre>
</code></pre>

      <p>Observa c√≥mo mantenemos la l√≥gica (validaciones y estados) dentro de la clase.</p>

      <h3>Cards de Refuerzo: Encapsulaci√≥n</h3>
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Modificadores de Acceso</h4>
          <p><code>private</code>: solo la clase. <code>protected</code>: clase y subclases. <code>public</code>: cualquier lugar. <code>default</code>: mismo paquete. Usa siempre el m√°s restrictivo posible para maximizar la seguridad del c√≥digo y ocultar detalles de implementaci√≥n.</p>
        </div>
        <div class="card-teorico">
          <h4>Getters y Setters</h4>
          <p>Proporcionan control sobre atributos privados. Los setters pueden validar datos antes de asignar, garantizando invariantes. Los getters pueden retornar copias defensivas para evitar mutaciones externas no deseadas del estado interno.</p>
        </div>
        <div class="card-teorico">
          <h4>Inmutabilidad</h4>
          <p>Las clases inmutables no pueden cambiar despu√©s de su creaci√≥n. Usa <code>final</code> en atributos y no proporciones setters. Beneficios: seguridad en multi-threading, cach√© seguro y l√≥gica m√°s predecible.</p>
        </div>
      </div>

      <h3>C√≥mo usar Encapsulaci√≥n en la Pr√°ctica</h3>
      <div class="info-box">
        <ol>
          <li><strong>Declara atributos como privados:</strong> usa <code>private</code> para todos los datos internos que no necesiten acceso externo directo.</li>
          <li><strong>Proporciona m√©todos p√∫blicos:</strong> crea getters para lectura y setters para escritura, ambos con validaci√≥n si es necesario.</li>
          <li><strong>Valida en los setters:</strong> aseg√∫rate de que los datos cumplan con las reglas de negocio antes de ser asignados.</li>
          <li><strong>Retorna copias en getters:</strong> cuando regreses objetos mutables (como listas), retorna copias para evitar modificaciones externas no deseadas.</li>
          <li><strong>Usa constructores para inicializar:</strong> inicializa el estado v√°lido del objeto desde el constructor.</li>
        </ol>
      </div>

      <h3>Buenas Pr√°cticas de Encapsulaci√≥n</h3>
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Principio de M√≠nimo Privilegio</h4>
          <p>Solo expone lo necesario. Evita hacer p√∫blicos atributos o m√©todos internos. Cada exposici√≥n innecesaria aumenta el acoplamiento y dificulta el mantenimiento futuro del c√≥digo.</p>
        </div>
        <div class="card-teorico">
          <h4>Validaci√≥n de Datos</h4>
          <p>Realiza validaciones robustas en constructores y setters. Lanza excepciones con mensajes claros cuando los datos no cumplan con los requisitos. Ejemplo: lanzar <code>IllegalArgumentException</code> si un saldo es negativo.</p>
        </div>
        <div class="card-teorico">
          <h4>Documentaci√≥n Clara</h4>
          <p>Documenta con Javadoc los m√©todos p√∫blicos indicando qu√© validan, qu√© excepciones pueden lanzar y qu√© retornan. Facilita el uso correcto por otros programadores.</p>
        </div>
        <div class="card-teorico">
          <h4>Copias Defensivas</h4>
          <p>Cuando regreses objetos mutables (listas, arrays), retorna copias en lugar del original. As√≠ evitas que c√≥digo externo modifique el estado interno sin pasar por los setters validadores.</p>
        </div>
        <div class="card-teorico">
          <h4>Invariantes del Objeto</h4>
          <p>Define condiciones que siempre deben ser ciertas (p. ej., saldo ‚â• 0). Garantiza estas condiciones mediante validaci√≥n en constructores y setters para mantener la integridad del objeto.</p>
        </div>
        <div class="card-teorico">
          <h4>Evita Acceso Directo a Datos</h4>
          <p>Nunca hagas p√∫blicos los atributos aunque no tengan setter. Usa getters/setters siempre. Esto permite cambiar la implementaci√≥n interna sin afectar a los consumidores del c√≥digo.</p>
        </div>
      </div>

    <section id="abstraccion">
      <h2>Abstracci√≥n</h2>
      <p><strong>Definici√≥n:</strong> La abstracci√≥n reduce la complejidad concentr√°ndose en los aspectos relevantes de un objeto para un contexto determinado. En Java se implementa con interfaces y clases abstractas que especifican contratos y comportamientos sin detallar la implementaci√≥n.</p>

      <h3>Abstract class vs Interface (cuando usar cada una)</h3>
      <ul>
        <li><strong>Interface:</strong> define un contrato puro; permite m√∫ltiples implementaciones; ideal para comportamientos que varias clases no relacionadas deben ofrecer.</li>
        <li><strong>Clase abstracta:</strong> √∫til cuando existe una relaci√≥n sem√°ntica (is-a) y se desea compartir c√≥digo com√∫n entre implementaciones.</li>
      </ul>

      <div class="figure">
        <svg class="svg-illustration" viewBox="0 0 700 160" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Abstracci√≥n - diagrama">
          <rect x="8" y="8" width="180" height="60" rx="10" fill="#eef6ff" stroke="#b7d7ff" />
          <text x="20" y="38" font-size="14" fill="#0f1724" font-weight="700">Drawable (interface)</text>

          <rect x="240" y="8" width="160" height="60" rx="10" fill="#fff7ed" stroke="#ffd7a7" />
          <text x="252" y="38" font-size="14" fill="#0f1724" font-weight="700">CanvasCircle</text>

          <rect x="480" y="8" width="160" height="60" rx="10" fill="#effaf5" stroke="#bff0d0" />
          <text x="492" y="38" font-size="14" fill="#0f1724" font-weight="700">SvgRectangle</text>

          <path d="M188 38 L240 38" stroke="#9aaed0" stroke-width="2" />
          <path d="M400 38 L480 38" stroke="#9aaed0" stroke-width="2" />
        </svg>
      </div>

      <h3>Ejemplo compilable (Pagable + Empleado)</h3>
      <p><strong>Explicaci√≥n:</strong> Interfaz Pagable define contrato. Empleado implementa la interfaz. Main demuestra polimorfismo: c√≥digo gen√©rico trabaja con Pagable sin conocer tipos espec√≠ficos.</p>
      <pre><code class="language-java">// Interfaz: define contrato puro (solo firma del m√©todo)
interface Pagable {
    // M√©todo abstracto que toda clase implementadora debe definir
    double calcularPago();
}

// Clase Empleado: implementa la interfaz Pagable
class Empleado implements Pagable {
    // Atributo private: nombre del empleado
    private String nombre;
    // Atributo private: salario bruto mensual
    private double salario;

    // Constructor: inicializa nombre y salario (validando salario no negativo)
    public Empleado(String n, double s) {
        // Asigna nombre
        nombre = n;
        // Asegura salario no negativo con Math.max
        salario = Math.max(0, s);
    }

    // Getter: retorna nombre del empleado
    public String getNombre() { return nombre; }
    // Getter: retorna salario bruto del empleado
    public double getSalario() { return salario; }
    
    // Implementaci√≥n del m√©todo abstracto de Pagable
    @Override
    // Calcula pago neto: 90% del salario bruto (retenci√≥n del 10%)
    public double calcularPago() { return salario * 0.90; }
}

// Main: demuestra polimorfismo (trabaja con tipo Pagable, no Empleado)
public class Main {
    public static void main(String[] args) {
        // Array de tipo Pagable (interfaz) que almacena objetos Empleado
        Pagable[] empleados = {
            // Crea Empleado y lo almacena como referencia Pagable
            new Empleado("Ana", 1200),
            new Empleado("Luis", 950),
            new Empleado("Mar√≠a", 1500)
        };
        
        // Encabezado del reporte
        System.out.println("=== C√ÅLCULO DE PAGOS ===");
        // Itera sobre cada elemento como Pagable (tipo interface)
        for (Pagable p : empleados) {
            // Cast necesario: convierte Pagable a Empleado para acceder a getNombre()
            Empleado e = (Empleado) p;
            // Imprime nombre (de Empleado) y pago neto (de Pagable calcularPago())
            System.out.println(e.getNombre() + " -> Pago neto: $" + String.format("%.2f", p.calcularPago()));
        }
    }
}
</code></pre>

      <p>Gracias a la abstracci√≥n, Pagable puede implementarse por m√∫ltiples clases diferentes.</p>

      <h3>Cards de Refuerzo: Abstracci√≥n</h3>
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Clases Abstractas</h4>
          <p>Define comportamiento com√∫n compartido entre subclases relacionadas. Usa <code>abstract</code> para especificar contratos que las subclases deben implementar. Ideal cuando existe relaci√≥n "is-a" y deseas compartir c√≥digo funcional.</p>
        </div>
        <div class="card-teorico">
          <h4>Interfaces y Contratos</h4>
          <p>Una interfaz define un contrato puro sin implementaci√≥n. Permite m√∫ltiples implementaciones y desacoplamiento. Ideal para comportamientos que varias clases no relacionadas deben ofrecer de forma polim√≥rfica.</p>
        </div>
        <div class="card-teorico">
          <h4>Polimorfismo</h4>
          <p>Permite objetos de diferentes tipos responder al mismo mensaje de manera apropiada. Gracias a la abstracci√≥n, c√≥digo gen√©rico puede trabajar con muchos tipos distintos sin conocer detalles espec√≠ficos de cada implementaci√≥n.</p>
        </div>
      </div>

      <h3>C√≥mo usar Abstracci√≥n en la Pr√°ctica</h3>
      <div class="info-box">
        <ol>
          <li><strong>Identifica abstracciones comunes:</strong> observa qu√© comportamientos compartir√°n varias clases (p. ej., calcular, dibujar, procesar).</li>
          <li><strong>Define contratos con interfaces:</strong> crea interfaces que especifiquen qu√© m√©todos deben implementar las clases.</li>
          <li><strong>Usa clases abstractas para comportamiento com√∫n:</strong> cuando varias clases comparten c√≥digo e implementaci√≥n, usa una clase abstracta base.</li>
          <li><strong>Programa hacia abstracciones:</strong> depende de interfaces o clases abstractas, no de implementaciones concretas, para mayor flexibilidad.</li>
          <li><strong>Aplica polimorfismo:</strong> escribe c√≥digo que trabaje con tipos abstractos; en tiempo de ejecuci√≥n responder√°n diferente seg√∫n su tipo real.</li>
        </ol>
      </div>

      <h3>Buenas Pr√°cticas de Abstracci√≥n</h3>
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Segregaci√≥n de Interfaces</h4>
          <p>Crea interfaces peque√±as y enfocadas en un √∫nico prop√≥sito. Evita interfaces "gordas" que obliguen a implementaciones innecesarias. Ejemplo: es mejor tener <code>Dibujable</code> y <code>Movible</code> separadas.</p>
        </div>
        <div class="card-teorico">
          <h4>Principio Abierto/Cerrado</h4>
          <p>Dise√±a clases e interfaces abiertas a extensi√≥n pero cerradas a modificaci√≥n. Nuevas implementaciones deben agregarse sin cambiar c√≥digo existente. Esto reduce riesgos de romper c√≥digo funcional.</p>
        </div>
        <div class="card-teorico">
          <h4>Principio de Sustituci√≥n de Liskov</h4>
          <p>Las subclases deben poder reemplazar a sus superclases sin romper el funcionamiento. Respeta el contrato de la clase base en tus implementaciones. Evita comportamientos inesperados.</p>
        </div>
        <div class="card-teorico">
          <h4>Entiende el Contexto de Uso</h4>
          <p>Abstrae solo lo relevante para el problema. Una abstracci√≥n demasiado gen√©rica es dif√≠cil de usar; una demasiado espec√≠fica reduce reutilizaci√≥n. Balance es clave.</p>
        </div>
        <div class="card-teorico">
          <h4>Evita Jerarqu√≠as Profundas</h4>
          <p>Mant√©n las jerarqu√≠as de herencia planas y simples. Jerarqu√≠as muy profundas son dif√≠ciles de entender y mantener. Si necesitas m√∫ltiples comportamientos, considera composici√≥n sobre herencia.</p>
        </div>
        <div class="card-teorico">
          <h4>Composici√≥n sobre Herencia</h4>
          <p>Cuando sea posible, prefiere composici√≥n (tener objetos) sobre herencia. Es m√°s flexible, evita el acoplamiento y permite cambiar comportamiento en tiempo de ejecuci√≥n.</p>
        </div>
      </div>

    <section id="aplicacion-practica">
      <h2>Aplicaci√≥n Pr√°ctica: Encapsulaci√≥n y Abstracci√≥n Combinadas</h2>
      <p>En la pr√°ctica, encapsulaci√≥n y abstracci√≥n funcionan juntas. La <strong>encapsulaci√≥n</strong> protege los datos internos mediante acceso controlado (private, getters, setters). La <strong>abstracci√≥n</strong> simplifica la complejidad exponiendo solo lo necesario mediante interfaces y m√©todos p√∫blicos, ocultando detalles de implementaci√≥n.</p>

      <h3>Caso Real: Sistema de Notificaciones</h3>
      <p>Imagina un sistema que env√≠a notificaciones por correo, SMS o push. Cada canal tiene detalles complejos, pero el usuario solo quiere invocar <code>enviar()</code>.</p>

      <pre><code class="language-java">// Interfaz Abstracta: contrato que todo canal debe cumplir
interface CanalNotificacion {
    // M√©todo abstracto: todo canal debe saber enviar
    void enviar(String destinatario, String mensaje);
}

// Implementaci√≥n Encapsulada: detalles internos privados
class EmailNotificacion implements CanalNotificacion {
    // Datos privados: servidor y puerto ocultos
    private String servidor = "smtp.example.com";
    private int puerto = 587;
    
    // M√©todo privado: configurar conexi√≥n (solo interno)
    private void conectar() {
        System.out.println("Conectando a " + servidor + ":" + puerto);
    }
    
    // Implementaci√≥n del contrato abstracto
    @Override
    public void enviar(String destinatario, String mensaje) {
        // Llama m√©todo privado interno
        conectar();
        // Valida email antes de enviar
        if (destinatario.contains("@")) {
            System.out.println("Email enviado a: " + destinatario);
        }
    }
}

// Otra implementaci√≥n de la interfaz (polimorfismo)
class SmsNotificacion implements CanalNotificacion {
    // Detalles privados diferentes al Email
    private String apiKey = "clave_privada_sms";
    
    @Override
    public void enviar(String destinatario, String mensaje) {
        // Implementaci√≥n diferente usando su propia l√≥gica
        System.out.println("SMS enviado a: " + destinatario);
    }
}

// Cliente: solo conoce la abstracci√≥n, no los detalles
public class SistemaNotificaciones {
    public static void main(String[] args) {
        // Polimorfismo: trabajamos con CanalNotificacion (abstracci√≥n)
        // pero creamos implementaciones concretas
        CanalNotificacion[] canales = {
            new EmailNotificacion(),
            new SmsNotificacion()
        };
        
        // Mismo c√≥digo gen√©rico para cualquier canal
        for (CanalNotificacion canal : canales) {
            // Encapsulaci√≥n: no conocemos detalles internos
            // Abstracci√≥n: solo usamos el contrato p√∫blico
            canal.enviar("usuario@example.com", "Hola!");
        }
    }
}
</code></pre>

      <h4>¬øPor qu√© funciona?</h4>
      <ul>
        <li><strong>Encapsulaci√≥n:</strong> Los detalles (servidor, puerto, apiKey) son <code>private</code>, protegidos.</li>
        <li><strong>Abstracci√≥n:</strong> El cliente solo ve <code>CanalNotificacion.enviar()</code>, ignorando c√≥mo cada canal lo implementa.</li>
        <li><strong>Flexibilidad:</strong> Agregar un nuevo canal (WhatsApp, Telegram) no requiere cambiar el cliente.</li>
      </ul>

      <h3>Cards de Teor√≠a: Integraci√≥n de Encapsulaci√≥n y Abstracci√≥n</h3>
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Encapsulaci√≥n Establece L√≠mites</h4>
          <p>Define qu√© datos son visibles y cu√°les ocultos mediante <code>private</code>, <code>protected</code> y <code>public</code>. Esto asegura que solo el c√≥digo autorizado acceda a datos sensibles. Ejemplo: un campo <code>password</code> nunca debe ser <code>public</code>.</p>
        </div>
        <div class="card-teorico">
          <h4>Abstracci√≥n Simplifica Interfaces</h4>
          <p>Define contrato p√∫blico mediante interfaces y m√©todos p√∫blicos, ocultando complejidad interna. El cliente solo necesita saber <strong>qu√©</strong> hace un m√©todo, no <strong>c√≥mo</strong> lo hace. Permite cambios internos sin afectar al cliente.</p>
        </div>
        <div class="card-teorico">
          <h4>Juntas Crean Robustez</h4>
          <p>Encapsulaci√≥n protege datos; abstracci√≥n protege l√≥gica de cambios. Combinadas, permiten evolucionar c√≥digo interno sin romper el contrato p√∫blico. Ejemplo: cambiar de base de datos sin que el cliente note diferencia.</p>
        </div>
      </div>

      <div class="cards-grid-teoricos" style="justify-items: center;">
        <div class="card-teorico" style="max-width: 280px;">
          <h4>Validaci√≥n en Puntos Controlados</h4>
          <p>La encapsulaci√≥n concentra validaciones en setters y constructores. La abstracci√≥n expone solo m√©todos p√∫blicos confiables. Esto garantiza que datos siempre sean v√°lidos porque pasan por validaciones en puntos √∫nicos y controlados.</p>
        </div>
      </div>

    </section>

    <section id="ejercicio">
      <h2>Ejercicio pr√°ctico compilable</h2>
      <p><strong>Enunciado:</strong> Crear Empleado implementando Pagable, luego c√≥digo que calcule pagos. Una soluci√≥n compilable completa.</p>

      <div class="solution">
        <h3>Soluci√≥n compilable √∫nica</h3>
        <p><strong>Explicaci√≥n:</strong> Interfaz Pagable + Empleado (encapsulaci√≥n + abstracci√≥n) + Main que demuestra polimorfismo. Todo en un archivo compilable.</p>
        <pre><code class="language-java">interface Pagable {
    double calcularPago();
}

class Empleado implements Pagable {
    private String nombre;
    private double salario;

    public Empleado(String nombre, double salario) {
        this.nombre = nombre;
        this.salario = Math.max(0, salario);
    }

    public String getNombre() { return nombre; }
    public double getSalario() { return salario; }

    @Override
    public double calcularPago() { return salario * 0.90; }
}

public class Main {
    public static void main(String[] args) {
        Empleado[] empleados = {
            new Empleado("Ana", 1200),
            new Empleado("Luis", 950),
            new Empleado("Mar√≠a", 1500)
        };
        
        System.out.println("=== C√ÅLCULO DE PAGOS ===");
        for (Empleado e : empleados) {
            System.out.printf("%s -> Salario: $%.2f | Pago neto: $%.2f\n", 
                e.getNombre(), e.getSalario(), e.calcularPago());
        }
    }
}
</code></pre>

        <h4>Salida esperada:</h4>
        <pre><code>=== C√ÅLCULO DE PAGOS ===
Ana -> Salario: $1200.00 | Pago neto: $1080.00
Luis -> Salario: $950.00 | Pago neto: $855.00
Mar√≠a -> Salario: $1500.00 | Pago neto: $1350.00
</code></pre>
      </div>

      <p>Este c√≥digo demuestra <strong>encapsulaci√≥n</strong> (atributos privados, validaciones) y <strong>abstracci√≥n</strong> (interfaz Pagable).</p>
</code></pre>
      </div>

      <p>Este ejemplo cubre tanto <strong>encapsulaci√≥n</strong> (control de acceso y validaciones) como <strong>abstracci√≥n</strong> (contrato <code>Pagable</code>).</p>
    </section>

    <section id="videos-educativos">
      <h2>Videos Educativos</h2>
      <div class="videos-grid">
        <div class="video-container">
          <h3>Encapsulamiento en la POO</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/ENCAPSULAMIENTO üíä en la POO.mp4" type="video/mp4">
              Tu navegador no soporta la reproducci√≥n de video. <a href="videos/ENCAPSULAMIENTO üíä en la POO.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Aprende los fundamentos de la encapsulaci√≥n: modificadores de acceso, getters y setters, y c√≥mo proteger la integridad de los datos.</p>
        </div>
        <div class="video-container">
          <h3>Abstracci√≥n - Clases y M√©todos Abstractos</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/121 . Curso de Java II POO II Abstracci√≥n - clases y m√©todos abstractos.mp4" type="video/mp4">
              Tu navegador no soporta la reproducci√≥n de video. <a href="videos/121 . Curso de Java II POO II Abstracci√≥n - clases y m√©todos abstractos.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Descubre c√≥mo usar clases abstractas e interfaces para simplificar la complejidad y crear c√≥digo m√°s flexible y mantenible.</p>
        </div>
      </div>
    </section>

    <p class="muted">Recursos adicionales: <a href="https://docs.oracle.com/javase/tutorial/java/IandI/" target="_blank" rel="noopener">Interfaces y Clases Abstractas (Oracle)</a> ‚Ä¢ <a href="https://www.geeksforgeeks.org/encapsulation-in-java/" target="_blank" rel="noopener">Encapsulation in Java (GeeksforGeeks)</a></p>

    <p><a href="index.html">Volver al inicio</a></p>
  </main>

  <footer class="site-footer">
    <p>&copy; P√°gina web POO 2026 - Todos los derechos reservados.</p>
  </footer>
  
  <!-- Botones de navegaci√≥n profesional -->
  <div class="nav-buttons-container">
    <button class="nav-button top" data-tooltip="Ir al principio" onclick="scrollToTop()">‚Üë</button>
    <button class="nav-button" data-tooltip="Subir p√°gina" onclick="scrollUp()">‚Üë</button>
    <button class="nav-button" data-tooltip="Bajar p√°gina" onclick="scrollDown()">‚Üì</button>
    <button class="nav-button bottom" data-tooltip="Ir al final" onclick="scrollToBottom()">‚Üì</button>
  </div>
  
  <script src="js/main.js" defer></script>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    
    function scrollUp() {
      window.scrollBy({ top: -window.innerHeight * 0.8, behavior: 'smooth' });
    }
    
    function scrollDown() {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
    }
  </script>
</body>
</html>