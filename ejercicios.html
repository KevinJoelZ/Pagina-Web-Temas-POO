<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ejercicios Prácticos - POO</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <header class="site-header">
    <nav class="navbar">
      <div class="brand"><a href="index.html">POO</a></div>
      <ul class="nav-links">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="fundamentos.html">Fundamentos</a></li>
        <li><a href="instanciacion.html">Instanciación</a></li>
        <li><a href="herencia.html">Herencia</a></li>
        <li><a href="ejercicios.html">Ejercicios</a></li>
        <li><a href="ejercicios-en-clase.html">Ejercicios en Clase</a></li>
        <li><a href="ejercicios-temas-poo.html">Ejercicios Temas POO</a></li>
        <li><a href="trabajos-autonomos.html">Trabajos Autónomos</a></li>
        <li><a href="clase-practica.html">Clase Práctica</a></li>
      </ul>
    </nav>
  </header>

  <main class="content">
    <h1>Ejercicios Prácticos: Modelado de Clases usando Herencia y Polimorfismo</h1>

    <p>Esta página te guía a través de ejercicios prácticos completos donde aplicarás herencia, polimorfismo y buenas prácticas de diseño. Cada ejercicio incluye análisis previo, diseño de la jerarquía, implementación y pruebas.</p>

    <section id="principios-ejercicios">
      <h2>Principios para Resolver Ejercicios</h2>
      <p>Antes de escribir código, debes analizar el problema, identificar las entidades, sus relaciones y comportamientos comunes. Este enfoque te garantiza un diseño robusto y extensible.</p>

      <h3>Pasos para Modelar Clases</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>1. Identificar Entidades</h4>
          <p>Del enunciado, lista todos los sustantivos: empleados, vehículos, animales, etc. Cada entidad potencial es una clase. Pregúntate: ¿es una cosa concreta que el sistema debe representar?</p>
        </div>
        <div class="card-profesional-green">
          <h4>2. Encontrar Relaciones "es-un"</h4>
          <p>Busca jerarquías naturales. ¿Un Empleado es-un Persona? ¿Un Perro es-un Animal? Las relaciones "es-un" sugieren herencia. No fuerces herencia si no hay verdadera relación.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>3. Definir Atributos Comunes</h4>
          <p>¿Qué datos comparten todas las subclases? Eso va en la superclase. Ej: Todos los Vehículos tienen marca, modelo, año. Atributos específicos van en subclases.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>4. Identificar Comportamientos</h4>
          <p>¿Qué acciones hacen los objetos? Esto son métodos. ¿Todos hacen la misma acción de forma diferente? Entonces es polimorfismo. Usa métodos abstractos en superclase, implementa en subclases.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>5. Diseñar Jerarquía</h4>
          <p>Dibuja un diagrama mostrando superclase(s) y subclases. Verifica que la estructura sea clara, lógica y no demasiado profunda (máximo 3 niveles). Asegúrate que cada relación es "es-un".</p>
        </div>
      </div>

      <div class="info-box">
        <h4>✓ Checklist de Diseño</h4>
        <ul>
          <li>¿Cada clase tiene una única responsabilidad?</li>
          <li>¿Las relaciones de herencia son auténticas (es-un)?</li>
          <li>¿La superclase contiene lo común; subclases lo específico?</li>
          <li>¿Los métodos abstractos están en la superclase?</li>
          <li>¿Se puede iterar polimórficamente sobre una colección?</li>
          <li>¿El código es fácil de entender y extender?</li>
        </ul>
      </div>
    </section>

    <section id="ejercicio-1">
      <h2>Ejercicio 1: Sistema de Gestión de Empresa</h2>
      <p><strong>Enunciado:</strong> Desarrolla un sistema para una empresa que gestiona diferentes tipos de empleados: administrativos, vendedores e ingenieros. Cada tipo tiene salario base, pero calcula bono de forma diferente. El sistema debe calcular el costo total de nómina y generar reportes.</p>

      <h3>Análisis Previo</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Entidades Identificadas</h4>
          <p><strong>Persona:</strong> base con nombre, apellido. <strong>Empleado:</strong> hereda de Persona, agrega salario, ID. <strong>Administrativo, Vendedor, Ingeniero:</strong> heredan de Empleado, con bonus diferente.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Atributos Compartidos</h4>
          <p>En Empleado: id, salario, departamento. En subclases: datos específicos (Vendedor tiene ventasRealizadas, Ingeniero tiene tecnologías, Administrativo tiene horasExtra).</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Métodos Polimórficos</h4>
          <p>Método <code>calcularBonus()</code> abstract en Empleado. Cada subclase implementa su propia lógica. Método <code>obtenerCostoTotal()</code> en empresa usa polimorfismo sin conocer tipos específicos.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Comportamientos Adicionales</h4>
          <p><code>toString()</code> para mostrar detalles. <code>generarReporte()</code> para imprimir información. Métodos que no varían están en la superclase (reutilización).</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Estructura de Clases</h4>
          <p>Persona (superclase) → Empleado (abstracta) → {Administrativo, Vendedor, Ingeniero}. Empresa contiene una lista de Empleados y métodos de gestión.</p>
        </div>
      </div>

      <h3>Solución Compilable</h3>
      <div class="solution">
        <p><strong>Explicación:</strong> Sistema compilable de empresa. Persona → Empleado (abstracta con método calcularBonus()) → Administrativo/Vendedor/Ingeniero. Cada subclase calcula bonus diferente. Empresa gestiona empleados polimórficamente usando una lista de tipo Empleado.</p>
        <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

// Base: Persona con nombre, apellido, edad
class Persona {
    protected String nombre, apellido;
    protected int edad;
    public Persona(String n, String a, int e) { nombre = n; apellido = a; edad = e; }
    public String getNombre() { return nombre + " " + apellido; }
}

// Abstracta: Empleado extiende Persona con id, salario y calcularBonus() abstracto
abstract class Empleado extends Persona {
    protected String id; protected double salario;
    public Empleado(String n, String a, int e, String id, double s) {
        super(n, a, e); this.id = id; this.salario = Math.max(0, s);
    }
    public abstract double calcularBonus(); // Polimorfismo: cada subclase implementa
    public double getCostoTotal() { return salario + calcularBonus(); }
    public double getSalario() { return salario; }
}

// Administrativo: bonus = 10% salario + $25 por hora extra
class Administrativo extends Empleado {
    private int horasExtra;
    public Administrativo(String n, String a, int e, String id, double s, int h) {
        super(n, a, e, id, s); horasExtra = h;
    }
    public double calcularBonus() { return salario * 0.10 + (horasExtra * 25); }
}

// Vendedor: bonus = 8% de ventas realizadas (comisión)
class Vendedor extends Empleado {
    private double ventas;
    public Vendedor(String n, String a, int e, String id, double s, double v) {
        super(n, a, e, id, s); ventas = Math.max(0, v);
    }
    public double calcularBonus() { return ventas * 0.08; }
}

// Ingeniero: bonus = 15% salario + $200 por proyecto completado
class Ingeniero extends Empleado {
    private int proyectos;
    public Ingeniero(String n, String a, int e, String id, double s, int p) {
        super(n, a, e, id, s); proyectos = p;
    }
    public double calcularBonus() { return salario * 0.15 + (proyectos * 200); }
}

// Empresa: gestor que maneja empleados polimórficamente sin conocer sus tipos
class Empresa {
    private List&lt;Empleado&gt; empleados = new ArrayList&lt;&gt;();
    public void agregarEmpleado(Empleado e) { empleados.add(e); }
    public double getCostoMensual() {
        double total = 0;
        for (Empleado e : empleados) total += e.getCostoTotal();
        return total;
    }
    public void reporte() {
        System.out.println("=== REPORTE EMPRESA ===");
        double sumaSalarios = 0, sumaBonus = 0;
        for (Empleado e : empleados) {
            double bonus = e.calcularBonus();
            System.out.println(e.getNombre() + " - Salario: $" + String.format("%.2f", e.getSalario()) + " Bonus: $" + String.format("%.2f", bonus));
            sumaSalarios += e.getSalario();
            sumaBonus += bonus;
        }
        System.out.println("\n--- RESUMEN ---");
        System.out.println("Costo Total: $" + String.format("%.2f", getCostoMensual()));
    }
}

// Main: demuestra polimorfismo - cada empleado calcula su bonus diferente
public class Main {
    public static void main(String[] args) {
        Empresa emp = new Empresa();
        emp.agregarEmpleado(new Administrativo("Ana", "García", 35, "A001", 1500, 8));
        emp.agregarEmpleado(new Vendedor("Carlos", "López", 40, "V001", 1200, 50000));
        emp.agregarEmpleado(new Ingeniero("María", "Martínez", 28, "I001", 2500, 5));
        emp.reporte();
    }
}
</code></pre>
      </div>
        // Crea e inmediatamente agrega un Vendedor
        // Parámetros: nombre, apellido, edad, id, salario, departamento, ventasRealizadas
        empresa.agregarEmpleado(new Vendedor("Carlos", "López", 40, "VEN001", 1200, "Ventas", 50000));
        
        // Crea e inmediatamente agrega un Ingeniero
        // Parámetros: nombre, apellido, edad, id, salario, departamento, proyectosCompletos, lenguajePrincipal
        empresa.agregarEmpleado(new Ingeniero("María", "Martínez", 28, "ING001", 2500, "Desarrollo", 5, "Java"));
        
        // Crea e inmediatamente agrega otro Administrativo con diferente ID
        empresa.agregarEmpleado(new Administrativo("Juan", "Pérez", 32, "ADM002", 1400, "Administración", 5));
        
        // Crea e inmediatamente agrega otro Vendedor con diferente ID
        empresa.agregarEmpleado(new Vendedor("Rosa", "Díaz", 38, "VEN002", 1300, "Ventas", 75000));

        // Llama al método generarReporte() de la empresa
        // Este método itera sobre todos los empleados e imprime información
        // Demuestra polimorfismo: cada empleado calcula su bonus diferente            // Suma el bonus de este empleado al total
            totalBonus += e.calcularBonus();
        }

        // Imprime separador para la sección de resumen
        System.out.println("--- RESUMEN ---");
        // Imprime total de todos los salarios (formateado a 2 decimales)
        System.out.println("Salarios Totales: $" + String.format("%.2f", totalSalarios));
        // Imprime total de todos los bonus
        System.out.println("Bonus Total: $" + String.format("%.2f", totalBonus));
        // Imprime costo mensual total (usando el método obtenerCostoMensual)
        System.out.println("Costo Mensual Total: $" + String.format("%.2f", obtenerCostoMensual()));
    }

    // Getter: retorna una copia de la lista de empleados
    public List&lt;Empleado&gt; obtenerEmpleados() {
        // Retorna una nueva ArrayList con los empleados (copia para evitar modificaciones externas).util.ArrayList;
import java.util.List;

public class Empresa {
    private String nombre;
    private List&lt;Empleado&gt; empleados;

    public Empresa(String nombre) {
        this.nombre = nombre;
        this.empleados = new ArrayList&lt;&gt;();
    }

    public void agregarEmpleado(Empleado e) {
        empleados.add(e);
        System.out.println(e.obtenerNombreCompleto() + " agregado a " + nombre);
    }

    public double obtenerCostoMensual() {
        double total = 0;
        for (Empleado e : empleados) {
            total += e.obtenerCostoTotal();
        }
        return total;
    }

    public void generarReporte() {
        System.out.println("=== REPORTE DE EMPRESA: " + nombre + " ===");
        System.out.println("Total de empleados: " + empleados.size());
        System.out.println();

        double totalSalarios = 0, totalBonus = 0;

        for (Empleado e : empleados) {
            System.out.println(e);
            System.out.println("  Bonus: $" + String.format("%.2f", e.calcularBonus()));
            System.out.println("  Costo Total: $" + String.format("%.2f", e.obtenerCostoTotal()));
            System.out.println();

            totalSalarios += e.getSalario();
            totalBonus += e.calcularBonus();
        }

        System.out.println("--- RESUMEN ---");
        System.out.println("Salarios Totales: $" + String.format("%.2f", totalSalarios));
        System.out.println("Bonus Total: $" + String.format("%.2f", totalBonus));
        System.out.println("Costo Mensual Total: $" + String.format("%.2f", obtenerCostoMensual()));
    }

    public List&lt;Empleado&gt; obtenerEmpleados() {
        return new ArrayList&lt;&gt;(empleados);
    }
}
</code></pre>

        <h4>5. Programa Principal</h4>
        <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Empresa empresa = new Empresa("TechCorp");

        empresa.agregarEmpleado(new Administrativo("Ana", "García", 35, "ADM001", 1500, "Administración", 8));
        empresa.agregarEmpleado(new Vendedor("Carlos", "López", 40, "VEN001", 1200, "Ventas", 50000));
        empresa.agregarEmpleado(new Ingeniero("María", "Martínez", 28, "ING001", 2500, "Desarrollo", 5, "Java"));
        empresa.agregarEmpleado(new Administrativo("Juan", "Pérez", 32, "ADM002", 1400, "Administración", 5));
        empresa.agregarEmpleado(new Vendedor("Rosa", "Díaz", 38, "VEN002", 1300, "Ventas", 75000));

        empresa.generarReporte();
    }
}
</code></pre>
      </div>

      <h3>Puntos Clave del Ejercicio</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Herencia en Cascada</h4>
          <p>Persona → Empleado → Subclases. Cada nivel agrega responsabilidades. Subclases heredan atributos/métodos del padre.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Clase Abstracta</h4>
          <p>Empleado no puede instanciarse directamente. Obliga a subclases a implementar <code>calcularBonus()</code>. Define contrato común.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Polimorfismo</h4>
          <p>En Empresa, <code>obtenerCostoMensual()</code> itera sobre una lista de Empleados sin conocer tipos específicos. Cada uno responde apropiadamente.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Extensibilidad</h4>
          <p>Agregar nuevo tipo (Director, Pasante) es fácil: extend Empleado, implementa calcularBonus(). Nada se rompe en código existente.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Encapsulación</h4>
          <p>Atributos protected/private, acceso mediante getters. Validaciones en constructores (salario ≥ 0). Estado consistente siempre.</p>
        </div>
      </div>
    </section>

    <section id="ejercicio-2">
      <h2>Ejercicio 2: Sistema de Transportes Públicos</h2>
      <p><strong>Enunciado:</strong> Modela un sistema de transporte público con diferentes vehículos: autobuses, metros y taxis. Cada uno calcula tarifa diferente, tiene capacidad específica, y reporta estado de ocupación. Implementa un gestor que calcule ingresos totales y validar capacidades.</p>

      <h3>Análisis y Diseño</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-green">
          <h4>Jerarquía Identificada</h4>
          <p>VehículoTransporte (superclase abstracta) con métodos calcularTarifa(), embarcar(), desembarcar(). Subclases: Autobús, Metro, Taxi con comportamientos específicos.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Polimorfismo de Tarifa</h4>
          <p>Cada vehículo calcula tarifa diferente: Autobús (fija), Metro (zona), Taxi (distancia). Método abstracto obliga implementación. Calculo polimórfico sin conocer tipo.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Manejo de Capacidad</h4>
          <p>Cada vehículo tiene capacidad máxima y ocupación actual. Validar antes de embarcar. Generar alertas si está lleno. Control de estado del vehículo.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Sistema de Gestión</h4>
          <p>Clase SistemaTransportes con colección de vehículos. Métodos: obtenerTarifaTotal(), generarReporte(), buscar vehículos disponibles, ruta óptima.</p>
        </div>
      </div>

      <h3>Implementación Compilable</h3>
      <div class="solution">
        <p><strong>Explicación:</strong> VehículoTransporte es la superclase abstracta. Subclases: Autobús (tarifa fija), Metro (tarifa por zona), Taxi (tarifa por km). SistemaTransportes gestiona vehículos polimórficamente. Método calcularTarifa() es abstracto: cada vehículo implementa diferente.</p>
        <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

// Superclase abstracta: VehículoTransporte define comportamiento común
abstract class VehiculoTransporte {
    protected String id, ruta;
    protected int capacidadMax, ocupacion;
    protected double tarifaBase;
    
    public VehiculoTransporte(String id, String ruta, int cap, double tarifa) {
        this.id = id; this.ruta = ruta; this.capacidadMax = cap; 
        this.ocupacion = 0; this.tarifaBase = tarifa;
    }
    public abstract double calcularTarifa();
    public boolean embarcar() { 
        if (ocupacion < capacidadMax) { ocupacion++; return true; } 
        return false; 
    }
    public boolean desembarcar() { 
        if (ocupacion > 0) { ocupacion--; return true; } 
        return false; 
    }
    public double getPorcentajeOcupacion() { return (ocupacion * 100.0) / capacidadMax; }
}

// Subclase 1: Autobús - tarifa fija de $1.50
class Autobus extends VehiculoTransporte {
    public Autobus(String id, String ruta, int cap) { super(id, ruta, cap, 1.50); }
    public double calcularTarifa() { return tarifaBase; }
}

// Subclase 2: Metro - tarifa basada en zona ($0.50 * zona)
class Metro extends VehiculoTransporte {
    private int zona;
    public Metro(String id, String ruta, int cap, int zona) { 
        super(id, ruta, cap, 0.50); this.zona = zona;
    }
    public double calcularTarifa() { return tarifaBase * zona; }
}

// Subclase 3: Taxi - tarifa base + $0.50 por km
class Taxi extends VehiculoTransporte {
    private double km;
    public Taxi(String id, String ruta, double km) { 
        super(id, ruta, 4, 2.00); this.km = km;
    }
    public void setKm(double k) { km = k; }
    public double calcularTarifa() { return tarifaBase + (km * 0.50); }
}

// Gestor del sistema de transportes con polimorfismo
class SistemaTransportes {
    private List&lt;VehiculoTransporte&gt; vehiculos = new ArrayList&lt;&gt;();
    public void agregarVehiculo(VehiculoTransporte v) { vehiculos.add(v); }
    public double obtenerIngresosTotales() {
        double total = 0;
        for (VehiculoTransporte v : vehiculos) 
            total += v.calcularTarifa() * v.ocupacion;
        return total;
    }
    public void reporte() {
        System.out.println("=== REPORTE TRANSPORTES ===");
        for (VehiculoTransporte v : vehiculos) {
            System.out.println(v.id + " - Ocupación: " + v.ocupacion + "/" + v.capacidadMax + 
                " - Tarifa: $" + String.format("%.2f", v.calcularTarifa()) + 
                " - Ingresos: $" + String.format("%.2f", v.calcularTarifa() * v.ocupacion));
        }
        System.out.println("Ingresos Totales: $" + String.format("%.2f", obtenerIngresosTotales()));
    }
}

// Main: demuestra polimorfismo de tarifa
public class Main {
    public static void main(String[] args) {
        SistemaTransportes st = new SistemaTransportes();
        
        // Crear vehículos: cada uno calcula tarifa diferente
        Autobus bus1 = new Autobus("BUS-001", "Ruta 1", 40);
        Metro metro1 = new Metro("MTR-001", "Línea A", 100, 2);
        Taxi taxi1 = new Taxi("TAX-001", "Sector Centro", 5.5);
        
        // Simular embarques
        for (int i = 0; i < 30; i++) bus1.embarcar();
        for (int i = 0; i < 80; i++) metro1.embarcar();
        for (int i = 0; i < 3; i++) taxi1.embarcar();
        
        // Agregar y generar reporte
        st.agregarVehiculo(bus1);
        st.agregarVehiculo(metro1);
        st.agregarVehiculo(taxi1);
        st.reporte();
    }
}
</code></pre>
      </div>

      <h3>Gestor del Sistema</h3>
      <p><strong>Explicación:</strong> Esta clase gestiona todos los vehículos del sistema. Demuestra polimorfismo: almacena vehículos de diferentes tipos (Autobús, Metro, Taxi) en una sola colección. Métodos como <code>obtenerIngresosTotales()</code> e <code>generarReporte()</code> funcionan con cualquier tipo de vehículo sin conocer cuál es.</p>
      <pre><code class="language-java">// Importar ArrayList y List
import java.util.ArrayList;
import java.util.List;

// Clase Gestor del Sistema de Transportes
public class SistemaTransportes {
    // Atributo private: lista que almacena vehículos de cualquier tipo
    private List&lt;VehículoTransporte&gt; vehículos;

    // Constructor: inicializa el sistema con una lista vacía de vehículos
    public SistemaTransportes() {
        // Crea una nueva ArrayList para almacenar vehículos
        this.vehículos = new ArrayList&lt;&gt;();
    }

    // Método para agregar un vehículo al sistema
    public void agregarVehículo(VehículoTransporte v) {
        // Agrega el vehículo a la lista (puede ser Autobús, Metro o Taxi)
        vehículos.add(v);
    }

    // Método que calcula los ingresos totales de todos los vehículos
    public double obtenerIngresosTotales() {
        // Inicializa acumulador en 0
        double total = 0;
        // Itera sobre cada vehículo en el sistema
        for (VehículoTransporte v : vehículos) {
            // Suma el ingreso de este vehículo (tarifa × ocupación actual)
            total += v.calcularTarifa() * v.getOcupacionActual();
        }
        // Retorna el total acumulado
        return total;
    }

    // Método que genera un reporte completo del sistema
    public void generarReporte() {
        // Imprime encabezado
        System.out.println("=== REPORTE DEL SISTEMA DE TRANSPORTES ===");
        // Itera sobre cada vehículo del sistema
        for (VehículoTransporte v : vehículos) {
            // Imprime la representación completa del vehículo
            System.out.println(v);
            // Imprime la tarifa calculada (polimórfica: cada tipo calcula diferente)
            System.out.println("  Tarifa: $" + String.format("%.2f", v.calcularTarifa()));
            // Imprime los ingresos de este vehículo (tarifa × pasajeros)
            System.out.println("  Ingresos: $" + String.format("%.2f", v.calcularTarifa() * v.getOcupacionActual()));
            System.out.println();
        }
        // Imprime los ingresos totales del sistema
        System.out.println("INGRESOS TOTALES: $" + String.format("%.2f", obtenerIngresosTotales()));
    }
}
</code></pre>
    </section>

    <section id="ejercicio-3">
      <h2>Ejercicio 3: Zoo - Gestión de Animales</h2>
      <p><strong>Enunciado:</strong> Implementa un sistema para un zoo que gestiona diferentes animales (carnívoros, herbívoros, omnívoros). Cada animal tiene nombre, edad, dieta, y comportamientos específicos (comer, dormir, hacer sonido). El sistema debe calcular cantidad de alimento diario y generar reporte de cuidado.</p>

      <h3>Solución Compilable</h3>
      <div class="solution">
        <p><strong>Explicación:</strong> Animal es la superclase abstracta. Carnívoro y Herbívoro implementan calcularAlimentoDiario() diferente (5% vs 8% del peso). Zoo gestiona animales polimórficamente. El polimorfismo permite iterar sin conocer tipos específicos.</p>
        <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

// Superclase abstracta: define comportamiento común
abstract class Animal {
    protected String nombre;
    protected int edad;
    protected double peso;
    
    public Animal(String n, int e, double p) { 
        nombre = n; edad = e; peso = p;
    }
    public abstract String getTipo();
    public abstract double calcularAlimentoDiario();
    public abstract void hacerSonido();
    
    public void dormir() { System.out.println(nombre + " duerme..."); }
    public void comer(double cant) { System.out.println(nombre + " come " + cant + " kg"); }
}

// Subclase 1: Carnívoro - come 5% de su peso
class Carnivoro extends Animal {
    public Carnivoro(String n, int e, double p) { super(n, e, p); }
    public String getTipo() { return "Carnívoro"; }
    public double calcularAlimentoDiario() { return peso * 0.05; } // 5% del peso
    public void hacerSonido() { System.out.println(nombre + " ruge: ¡ROAAARRR!"); }
}

// Subclase 2: Herbívoro - come 8% de su peso
class Herbivoro extends Animal {
    public Herbivoro(String n, int e, double p) { super(n, e, p); }
    public String getTipo() { return "Herbívoro"; }
    public double calcularAlimentoDiario() { return peso * 0.08; } // 8% del peso
    public void hacerSonido() { System.out.println(nombre + " emite sonido suave"); }
}

// Gestor: Zoo maneja animales polimórficamente
class Zoo {
    private String nombre;
    private List&lt;Animal&gt; animales = new ArrayList&lt;&gt;();
    
    public Zoo(String n) { nombre = n; }
    public void agregarAnimal(Animal a) { animales.add(a); }
    public double getAlimentoTotalDiario() {
        double total = 0;
        for (Animal a : animales) total += a.calcularAlimentoDiario();
        return total;
    }
    public void reporte() {
        System.out.println("=== ZOO: " + nombre + " ===");
        double totalAlimento = 0;
        for (Animal a : animales) {
            double alim = a.calcularAlimentoDiario();
            System.out.println(a.nombre + " (" + a.getTipo() + ") - Peso: " + a.peso + " kg - Alimento: " + String.format("%.2f", alim) + " kg");
            a.hacerSonido();
            totalAlimento += alim;
        }
        System.out.println("\nAlimento Total Diario: " + String.format("%.2f", totalAlimento) + " kg");
    }
}

// Main: demuestra polimorfismo - cada animal come diferente según su tipo
public class Main {
    public static void main(String[] args) {
        Zoo zoo = new Zoo("Zoológico Central");
        
        zoo.agregarAnimal(new Carnivoro("León", 8, 180));
        zoo.agregarAnimal(new Carnivoro("Tigre", 6, 160));
        zoo.agregarAnimal(new Herbivoro("Elefante", 20, 5000));
        zoo.agregarAnimal(new Herbivoro("Jirafa", 15, 800));
        
        zoo.reporte();
    }
}
</code></pre>
    </section>

    <h3>Resumen de Patrones Aplicados</h3>
    <div class="cards-grid-teoricos">
      <div class="card-teorico">
        <h4>Jerarquía Clara</h4>
        <p>Superclase define estructura común, subclases especializan. Relaciones "es-un" auténticas. Máximo 3 niveles de profundidad.</p>
      </div>
      <div class="card-teorico">
        <h4>Métodos Abstractos</h4>
        <p>Define contratos en superclase. Cada subclase implementa según su lógica. Polimorfismo garantizado sin conocer tipos específicos.</p>
      </div>
      <div class="card-teorico">
        <h4>Colecciones Polimórficas</h4>
        <p>Una lista de Empleados, Vehículos, Animales puede contener cualquier subclase. Itera y cada uno responde apropiadamente.</p>
      </div>
      <div class="card-teorico">
        <h4>Encapsulación</h4>
        <p>Atributos private/protected con getters/setters. Validaciones en constructores. Estado consistente siempre.</p>
      </div>
      <div class="card-teorico">
        <h4>Responsabilidad Única</h4>
        <p>Cada clase hace una cosa bien. Empleado gestiona datos de empleado, Empresa gestiona empleados. Separación clara.</p>
      </div>
      <div class="card-teorico">
        <h4>Extensibilidad</h4>
        <p>Agregar nuevas subclases es fácil sin modificar código existente. Sigue principio Open/Closed: abierto a extensión, cerrado a modificación.</p>
      </div>
    </div>

    <section id="buenas-practicas-ejercicios">
      <h2>Buenas Prácticas en Ejercicios</h2>
      <div class="info-box">
        <ol>
          <li><strong>Antes de codificar:</strong> Dibuja la jerarquía. Lista atributos y métodos en cada clase. Verifica relaciones.</li>
          <li><strong>Usa clases abstractas:</strong> Cuando varios tipos comparten comportamiento pero lo implementan diferente.</li>
          <li><strong>Métodos abstractos:</strong> Define en superclase, implementa en subclases. Garantiza contrato.</li>
          <li><strong>Polimorfismo en iteración:</strong> Usa colecciones de la superclase. Cada objeto responde según su tipo.</li>
          <li><strong>Validación en constructores:</strong> Asegura estado válido desde el inicio. Evita bugs posteriores.</li>
          <li><strong>toString() descriptivo:</strong> Implementa en todas las clases. Facilita debugging y reportes.</li>
          <li><strong>Separación de responsabilidades:</strong> Clase base para datos comunes, subclases para comportamiento específico, gestores para lógica de negocio.</li>
          <li><strong>Reutilización sobre duplicación:</strong> Si una subclase necesita código similar a otra, muévelo a la superclase.</li>
          <li><strong>Evita jerarquías profundas:</strong> Máximo 3 niveles. Después, considera composición sobre herencia.</li>
          <li><strong>Documenta la jerarquía:</strong> Comentarios claros explicando relaciones y propósito de cada clase.</li>
        </ol>
      </div>
    </section>

    <section id="desafios-propuestos">
      <h2>Desafíos Propuestos</h2>
      <p>Intenta resolver estos desafíos aplicando lo aprendido:</p>

      <h3>Desafío 1: Sistema Bancario Avanzado</h3>
      <p>Crea cuentas: Ahorros, Corriente, Inversión. Cada una calcula interés diferente, tiene límites y comisiones diferentes. Implementa transferencias entre cuentas, historial de movimientos y reportes de rentabilidad.</p>

      <h3>Desafío 2: Juego RPG</h3>
      <p>Personajes: Guerrero, Mago, Arquero. Cada uno atacar diferente, tiene habilidades especiales, puntos de vida y mana. Implementa combate polimórfico donde cada personaje ataca según su tipo.</p>

      <h3>Desafío 3: Plataforma de Streaming</h3>
      <p>Contenido: Series, Películas, Documentales. Cada uno tiene duración diferente, género, calificación. Usuario puede ver contenido (tracking de reproducción). Implementa recomendaciones basadas en historial.</p>
    </section>

    <section id="videos-educativos">
      <h2>Videos Educativos</h2>
      <div class="videos-grid">
        <div class="video-container">
          <h3>Tutorial Java POO - Ejercicios Prácticos</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/Tutorial Java POO_ Ejemplo de Herencia y Polimorfismo en Programación Orientada .mp4" type="video/mp4">
              Tu navegador no soporta la reproducción de video. <a href="videos/Tutorial Java POO_ Ejemplo de Herencia y Polimorfismo en Programación Orientada .mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Completa tutorial práctico de Programación Orientada a Objetos en Java con ejercicios resueltos, aplicando conceptos como herencia, polimorfismo y encapsulación en proyectos reales.</p>
        </div>
      </div>
    </section>

    <p class="muted">Recursos adicionales: <a href="https://docs.oracle.com/javase/tutorial/java/IandI/" target="_blank" rel="noopener">Interfaces and Classes (Oracle)</a> • <a href="https://www.geeksforgeeks.org/polymorphism-in-java/" target="_blank" rel="noopener">Polymorphism in Java (GeeksforGeeks)</a></p>

    <p><a href="index.html">Volver al inicio</a></p>
  </main>

  <footer class="site-footer">
    <p>&copy; Página web POO 2026 - Todos los derechos reservados.</p>
  </footer>
  
  <!-- Botones de navegación profesional -->
  <div class="nav-buttons-container">
    <button class="nav-button top" data-tooltip="Ir al principio" onclick="scrollToTop()">↑</button>
    <button class="nav-button" data-tooltip="Subir página" onclick="scrollUp()">↑</button>
    <button class="nav-button" data-tooltip="Bajar página" onclick="scrollDown()">↓</button>
    <button class="nav-button bottom" data-tooltip="Ir al final" onclick="scrollToBottom()">↓</button>
  </div>
  
  <script src="js/main.js" defer></script>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    
    function scrollUp() {
      window.scrollBy({ top: -window.innerHeight * 0.8, behavior: 'smooth' });
    }
    
    function scrollDown() {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
    }
  </script>
</body>
</html>
