<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Instanciación de Objetos - POO</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <header class="site-header">
    <nav class="navbar">
      <div class="brand"><a href="index.html">POO</a></div>
      <ul class="nav-links">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="fundamentos.html">Fundamentos</a></li>
        <li><a href="instanciacion.html">Instanciación</a></li>
        <li><a href="herencia.html">Herencia</a></li>
        <li><a href="ejercicios.html">Ejercicios</a></li>
      </ul>
    </nav>
  </header>

  <main class="content">
    <h1>Instanciación de Objetos y Manipulación de Atributos y Métodos</h1>

    <p>En esta página aprenderás cómo crear instancias de objetos en Java, cómo manipular sus atributos (propiedades) y cómo invocar sus métodos. La instanciación es el proceso fundamental que convierte una clase (plantilla) en objetos reales con los que trabajamos en nuestros programas.</p>

    <section id="que-es-instanciacion">
      <h2>¿Qué es la Instanciación?</h2>
      <p><strong>Definición:</strong> La instanciación es el proceso de crear un objeto concreto a partir de una clase. Una clase es un plano o plantilla; una instancia es un objeto real en memoria con su propio estado (valores de atributos). Cada instancia es independiente de las demás, aunque comparten la misma estructura definida en la clase.</p>

      <h3>Clase vs Instancia</h3>
      <ul>
        <li><strong>Clase:</strong> es el tipo, el molde, la especificación de qué atributos y métodos tendrá cada objeto.</li>
        <li><strong>Instancia (objeto):</strong> es una copia concreta de esa clase con valores específicos para sus atributos.</li>
      </ul>

      <div class="figure">
        <svg class="svg-illustration" viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Clase vs Instancia">
          <rect x="20" y="20" width="240" height="160" rx="10" fill="#eef6ff" stroke="#48bb78" stroke-width="2"/>
          <text x="40" y="50" font-size="16" font-weight="700" fill="#0f1724">Clase: Persona</text>
          <text x="40" y="75" font-size="13" fill="#374151">atributos:</text>
          <text x="50" y="95" font-size="12" fill="#374151">- nombre: String</text>
          <text x="50" y="110" font-size="12" fill="#374151">- edad: int</text>
          <text x="50" y="125" font-size="12" fill="#374151">- correo: String</text>
          <text x="40" y="155" font-size="12" fill="#6b7280" font-style="italic">Plantilla/Molde</text>

          <rect x="340" y="20" width="150" height="70" rx="8" fill="#fff7ed" stroke="#fbbf24" stroke-width="2"/>
          <text x="360" y="45" font-size="14" font-weight="700" fill="#0f1724">Ana</text>
          <text x="360" y="62" font-size="12" fill="#374151">edad: 28</text>
          <text x="360" y="77" font-size="12" fill="#374151">correo: ana@email.com</text>

          <rect x="340" y="110" width="150" height="70" rx="8" fill="#fff7ed" stroke="#fbbf24" stroke-width="2"/>
          <text x="360" y="135" font-size="14" font-weight="700" fill="#0f1724">Luis</text>
          <text x="360" y="152" font-size="12" fill="#374151">edad: 35</text>
          <text x="360" y="167" font-size="12" fill="#374151">correo: luis@email.com</text>

          <path d="M260 50 L340 50" stroke="#9aaed0" stroke-width="2" marker-end="url(#arrowhead)"/>
          <path d="M260 140 L340 140" stroke="#9aaed0" stroke-width="2" marker-end="url(#arrowhead)"/>

          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#9aaed0"/>
            </marker>
          </defs>

          <text x="280" y="40" font-size="11" fill="#6b7280">instancia 1</text>
          <text x="280" y="135" font-size="11" fill="#6b7280">instancia 2</text>
        </svg>
      </div>

      <h3>¿Cómo crear una instancia?</h3>
      <p>En Java, usamos la palabra clave <code>new</code> seguida del constructor de la clase para crear una instancia:</p>
      <pre><code class="language-java">// Sintaxis general
TipoClase nombreVariable = new TipoClase(argumentosDelConstructor);

// Ejemplo
Persona ana = new Persona("Ana", 28, "ana@email.com");
Persona luis = new Persona("Luis", 35, "luis@email.com");
</code></pre>

      <p>Cada variable (<code>ana</code>, <code>luis</code>) apunta a una instancia diferente en memoria con su propio estado.</p>

      <h3>Conceptos Clave en Instanciación</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Operador new</h4>
          <p>Palabra clave que asigna memoria en el heap para el nuevo objeto. Invoca automáticamente el constructor apropiado. <strong>Siempre</strong> debes usar <code>new</code> para crear objetos (excepto String que tiene casos especiales).</p>
        </div>
        <div class="card-profesional-green">
          <h4>Referencia vs Objeto</h4>
          <p>La variable que declares es una <strong>referencia</strong> (apuntador) al objeto, no el objeto en sí. Múltiples referencias pueden apuntar al mismo objeto. Asignar una variable a otra copia la referencia, no clona el objeto.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Null: Referencia Vacía</h4>
          <p>Una variable de referencia puede contener <code>null</code>, lo que significa "no apunta a nada". Acceder a métodos/atributos de <code>null</code> causa <code>NullPointerException</code>. Siempre valida antes de usar referencias.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Independencia de Estado</h4>
          <p>Cada instancia tiene su propio estado (valores de atributos) completamente independiente. Cambiar un atributo en una instancia no afecta a otras, aunque sean de la misma clase.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Inicialización en Constructor</h4>
          <p>El constructor ejecuta código de inicialización cuando se crea el objeto. Es el lugar ideal para validar datos, establecer valores iniciales válidos y garantizar que el objeto nace en un estado consistente.</p>
        </div>
      </div>
    </section>

    <section id="constructores">
      <h2>Constructores: Inicializando Objetos</h2>
      <p><strong>Definición:</strong> Un constructor es un método especial que se ejecuta cuando creas una instancia. Se usa para inicializar el estado del objeto. Todo constructor tiene el mismo nombre que la clase.</p>

      <h3>Tipos de Constructores</h3>
      
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Constructor por Defecto (sin argumentos)</h4>
          <p>Si no defines ningún constructor, Java proporciona uno automáticamente que inicializa atributos con valores por defecto (0, null, false, etc.). Puedes definir explícitamente uno vacío para mayor control.</p>
        </div>
        <div class="card-teorico">
          <h4>Constructor Parametrizado</h4>
          <p>Acepta parámetros para inicializar atributos con valores específicos. Es lo más común. Permite crear objetos con estado válido desde el inicio.</p>
        </div>
        <div class="card-teorico">
          <h4>Sobrecarga de Constructores</h4>
          <p>Puedes definir múltiples constructores con diferentes firmas (diferentes números o tipos de parámetros). Java elige el correcto según los argumentos que pases al usar <code>new</code>.</p>
        </div>
      </div>

      <h3>Ejemplo: Clase con Constructores</h3>
      <p><strong>Explicación:</strong> Esta clase demuestra diferentes tipos de constructores. El constructor vacío (<code>por defecto</code>) inicializa con valores por defecto. El constructor parametrizado es el más común. El constructor alternativo usa <code>this()</code> para delegar a otro constructor (delegación), evitando código duplicado.</p>
      <pre><code class="language-java">// Clase que demostra diferentes constructores
public class Estudiante {
    // Atributo private: nombre del estudiante
    private String nombre;
    // Atributo private: edad del estudiante
    private int edad;
    // Atributo private: promedio académico
    private double promedio;

    // Constructor 1: Constructor vacío (sin argumentos)
    // Se ejecuta cuando se crea: new Estudiante()
    public Estudiante() {
        // Inicializa nombre con valor por defecto
        this.nombre = "Desconocido";
        // Inicializa edad en 0
        this.edad = 0;
        // Inicializa promedio en 0.0
        this.promedio = 0.0;
    }

    // Constructor 2: Constructor parametrizado (el más común)
    // Se ejecuta cuando se crea: new Estudiante("Ana", 20, 85.5)
    public Estudiante(String nombre, int edad, double promedio) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
        // Valida que el promedio esté entre 0 y 100 usando Math.max y Math.min
        // Math.max(0, valor) asegura que no sea menor a 0
        // Math.min(100, resultado) asegura que no sea mayor a 100
        this.promedio = Math.max(0, Math.min(100, promedio)); // validación: 0-100
    }

    // Constructor 3: Constructor alternativo (menos parámetros)
    // Se ejecuta cuando se crea: new Estudiante("Ana", 20)
    public Estudiante(String nombre, int edad) {
        // Delega a otro constructor usando this()
        // this(nombre, edad, 0.0) llama al constructor parametrizado
        // Evita duplicación de código de validación
        this(nombre, edad, 0.0); // delegar a otro constructor
    }

    // Getters: métodos públicos para leer atributos privados
    public String getNombre() { return nombre; }
    // Getter para edad
    public int getEdad() { return edad; }
    // Getter para promedio
    public double getPromedio() { return promedio; }

    // Setter: método público para modificar el promedio con validación
    public void setPromedio(double promedio) {
        // Valida que el promedio esté entre 0 y 100
        this.promedio = Math.max(0, Math.min(100, promedio));
    }
}
</code></pre>

      <h3>Usando los Constructores</h3>
      <pre><code class="language-java">// Crear instancia con constructor vacío
Estudiante est1 = new Estudiante();

// Crear instancia con parámetros
Estudiante est2 = new Estudiante("Carlos", 20, 85.5);

// Crear instancia con constructor alternativo
Estudiante est3 = new Estudiante("Marta", 19);
</code></pre>

      <h3>Patrones Comunes en Constructores</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Delegación con this()</h4>
          <p>Un constructor puede invocar otro constructor de la misma clase usando <code>this(parámetros)</code>. Útil para evitar duplicación de código. <code>this()</code> debe ser la primera línea del constructor.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Validación en Constructor</h4>
          <p>Valida todos los parámetros antes de asignarlos a atributos. Lanza <code>IllegalArgumentException</code> si los datos son inválidos. Garantiza que todo objeto nace en estado válido, sin datos inconsistentes.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Constructor de Copia</h4>
          <p>Constructor que recibe otro objeto de la misma clase y copia su estado. Útil para crear clones: <code>new Persona(otraPersona)</code>. Evita compartir referencias a objetos mutables.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Constructores Sobrecargados</h4>
          <p>Múltiples constructores con diferentes firmas. Java elige automáticamente según los argumentos. Permite máxima flexibilidad: crear objetos con datos completos o parciales según la situación.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Inicialización de Campos Finales</h4>
          <p>Los campos declarados <code>final</code> deben inicializarse en el constructor o en la declaración. Después no pueden cambiar. Ideal para valores inmutables como IDs o nombres que nunca deben variar.</p>
        </div>
      </div>
    </section>

    <section id="ciclo-vida">
      <h2>Ciclo de Vida de un Objeto</h2>
      <p>Todo objeto en Java sigue un ciclo de vida bien definido: nacimiento, vida útil y muerte. Entender este ciclo es fundamental para escribir código eficiente y sin fugas de memoria.</p>

      <h3>Fases del Ciclo de Vida</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>1. Creación (new)</h4>
          <p><strong>Cuándo:</strong> Ejecutas <code>new NombreClase()</code>. <strong>Qué ocurre:</strong> Se asigna memoria en el heap, se inicializan atributos a valores por defecto, se ejecuta el constructor. <strong>Resultado:</strong> Objeto listo en memoria.</p>
        </div>
        <div class="card-profesional-green">
          <h4>2. Vida Útil (uso)</h4>
          <p><strong>Cuándo:</strong> Tienes referencias válidas al objeto y lo usas. <strong>Qué ocurre:</strong> Invocas métodos, lees/escribes atributos, el objeto cambia de estado. <strong>Duración:</strong> Mientras exista al menos una referencia activa.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>3. Pérdida de Referencias</h4>
          <p><strong>Cuándo:</strong> El objeto sale de scope o todas sus referencias se eliminan. <strong>Qué ocurre:</strong> El objeto se vuelve inaccesible desde el código. Java marca el objeto para garbage collection.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>4. Garbage Collection</h4>
          <p><strong>Cuándo:</strong> El garbage collector (JVM) necesita liberar memoria. <strong>Qué ocurre:</strong> Se ejecuta <code>finalize()</code> (en versiones antiguas) y se libera la memoria. <strong>Cuándo:</strong> No es determinístico, ocurre cuando la JVM lo decide.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>5. Destrucción (finalize)</h4>
          <p><strong>Método finalize():</strong> Se ejecuta antes de que el garbage collector libere el objeto. Rara vez se usa en código moderno. Mejor usar try-with-resources o métodos cleanup() explícitos para liberar recursos.</p>
        </div>
      </div>

      <h3>Ejemplo Visual del Ciclo de Vida</h3>
      <p><strong>Explicación:</strong> Este programa demuestra el ciclo de vida completo de un objeto en Java. La FASE 1 es la creación con <code>new</code>. La FASE 2 es el uso del objeto. La FASE 3 ocurre cuando se pierde la referencia y el objeto se vuelve inaccesible. La FASE 4 y 5 suceden automáticamente cuando el garbage collector libera la memoria.</p>
      <pre><code class="language-java">// Clase de ejemplo para demostrar ciclo de vida de objetos
public class EjemploCicloVida {
    // Método main: punto de entrada del programa
    public static void main(String[] args) {
        // FASE 1: CREACIÓN - Se ejecuta 'new', se asigna memoria, se invoca constructor
        // Se crea primer objeto Persona con nombre "Ana" y edad 28
        Persona p1 = new Persona("Ana", 28);
        // Imprime confirmación de creación
        System.out.println("1. Objeto creado: " + p1.getNombre());

        // FASE 2: VIDA ÚTIL - El objeto existe y lo usamos
        // Modifica la edad del objeto usando el método setEdad()
        p1.setEdad(29);
        // Imprime la edad modificada
        System.out.println("2. Edad modificada: " + p1.getEdad());

        // FASE 3: PÉRDIDA DE REFERENCIAS
        // Crea un segundo objeto Persona con nombre "Luis"
        Persona p2 = new Persona("Luis", 35);
        // Reasigna la variable p1 para que apunte al nuevo objeto (p2)
        p1 = p2;  // Ahora p1 apunta a Luis
        // El objeto "Ana" que p1 apuntaba está ahora sin referencias
        // Java marca automáticamente "Ana" como candidata para garbage collection
        // "Ana" ahora es inaccesible y será recolectada

        // Imprime el nuevo nombre al que apunta p1
        System.out.println("3. p1 ahora es: " + p1.getNombre());
        
        // FASE 4 y 5: GARBAGE COLLECTION Y DESTRUCCIÓN
        // Cuando el programa termina o no hay más referencias a los objetos,
        // el garbage collector (recolector de basura) de Java automáticamente
        // libera la memoria ocupada por los objetos sin referencias.
        // El programador NO controla cuándo ocurre exactamente.
        // p2 (Luis) también será recolectado cuando salga de scope o se pierda la referencia.
    }
}
</code></pre>
    </section>

    <section id="relaciones-objetos">
      <h2>Relaciones entre Objetos</h2>
      <p>En programación orientada a objetos, los objetos no existen aislados. Interactúan con otros objetos formando relaciones que modelan el mundo real. Las relaciones permiten crear estructuras complejas y reutilizables.</p>

      <h3>Tipos Principales de Relaciones</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Asociación</h4>
          <p>Una clase "usa" o tiene referencia a otra. Ejemplo: <code>Persona</code> tiene una referencia a <code>Dirección</code>. Las clases son independientes; pueden existir por separado. La relación es débil, sin dependencia fuerte.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Composición</h4>
          <p>Una clase "contiene" objetos de otra como partes componentes. Ejemplo: <code>Auto</code> contiene <code>Motor</code>, <code>Ruedas</code>, etc. Si la clase padre se destruye, las partes también. Relación fuerte: "tiene-a".</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Agregación</h4>
          <p>Similar a composición, pero más débil. El todo no "posee" las partes; simplemente las agrupa. Ejemplo: <code>Equipo</code> contiene <code>Jugadores</code>. Los jugadores pueden existir sin el equipo.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Herencia</h4>
          <p>Una clase "extiende" o hereda de otra. Ejemplo: <code>Empleado</code> hereda de <code>Persona</code>. Relación "es-un": <code>Empleado es un Persona</code>. Reutiliza código y crea jerarquías.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Dependencia</h4>
          <p>Una clase depende de otra para funcionar, pero sin poseerla. Ejemplo: Un método recibe un parámetro de otra clase. Relación de corta duración; típicamente dentro de un método.</p>
        </div>
      </div>

      <h3>Ejemplo: Composición</h3>
      <p><strong>Explicación:</strong> Composición es cuando una clase contiene objetos de otra clase. <code>Persona</code> compone una <code>Dirección</code>. Si la Persona se destruye, también su dirección. Es una relación fuerte de "tiene-a".</p>
      <pre><code class="language-java">// Clase Dirección: representa una ubicación
public class Dirección {
    // Atributo private: calle de la dirección
    private String calle;
    // Atributo private: ciudad de la dirección
    private String ciudad;
    // Atributo private: código postal de la dirección
    private String codigoPostal;

    // Constructor: inicializa todos los datos de la dirección
    public Dirección(String calle, String ciudad, String codigoPostal) {
        // Asigna la calle
        this.calle = calle;
        // Asigna la ciudad
        this.ciudad = ciudad;
        // Asigna el código postal
        this.codigoPostal = codigoPostal;
    }

    // Sobrescribe toString para representación legible
    @Override
    public String toString() {
        // Retorna la dirección formateada como string
        return calle + ", " + ciudad + " " + codigoPostal;
    }
}

// Clase Persona - COMPONE una Dirección
public class Persona {
    // Atributo private: nombre de la persona
    private String nombre;
    // Atributo private: edad de la persona
    private int edad;
    // Atributo private: objeto Dirección (COMPOSICIÓN)
    // Persona "tiene-a" una Dirección como parte de sí misma
    private Dirección dirección;

    // Constructor: recibe parámetros de persona + la dirección como objeto
    public Persona(String nombre, int edad, Dirección dirección) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
        // Asigna la dirección (objeto compuesto)
        this.dirección = dirección;
    }

    // Método que muestra información de la persona incluyendo su dirección
    public void mostrarInfo() {
        // Imprime nombre y edad de la persona
        System.out.println(nombre + ", " + edad + " años");
        // Imprime la dirección (se invoca toString() automáticamente)
        System.out.println("Vive en: " + dirección);
    }
}

// Clase de uso: demuestra composición en acción
public class Main {
    // Método main: punto de entrada
    public static void main(String[] args) {
        // Crea un objeto Dirección primero
        Dirección dir = new Dirección("Calle Principal 123", "Madrid", "28001");
        // Crea un objeto Persona que COMPONE la Dirección
        // Persona necesita una Dirección para estar completa
        Persona p = new Persona("Ana", 28, dir);
        // Llama al método que muestra información
        p.mostrarInfo();
        // Salida esperada:
        // Ana, 28 años
        // Vive en: Calle Principal 123, Madrid 28001
    }
}
</code></pre>
    </section>

    <section id="atributos">
      <h2>Manipulación de Atributos</h2>
      <p>Los atributos (campos) son variables que almacenan el estado de un objeto. Se manipulan principalmente a través de getters (lectura) y setters (escritura). Una buena manipulación de atributos es fundamental para la encapsulación y el mantenimiento del código.</p>

      <h3>Principios de Acceso a Atributos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Atributos Privados</h4>
          <p>Siempre usa <code>private</code> para los atributos de datos. Esto impide acceso directo no controlado desde fuera de la clase. Obliga a usar getters/setters, dándote control total sobre validación y consistencia de datos.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Getter: Lectura Segura</h4>
          <p>Método público que retorna el valor de un atributo privado. Por convención, se nombra <code>get</code> + nombre capitalizado. <strong>Nunca</strong> modifiques el estado en un getter. Pueden retornar copias defensivas si es necesario.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Setter: Escritura Validada</h4>
          <p>Método público que modifica un atributo privado con validación. Por convención, se nombra <code>set</code> + nombre. Siempre valida el nuevo valor antes de asignarlo. Lanza excepciones si el valor es inválido.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Copias Defensivas</h4>
          <p>Si un atributo es mutable (lista, array, objeto), retorna una copia en el getter, no la original. Así evitas que código externo modifique el estado interno sin pasar por validaciones. Importante para mantener la integridad.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Atributos Inmutables (final)</h4>
          <p>Un atributo <code>final</code> no puede cambiar después de inicializarse. Ideal para valores que deben ser constantes: IDs, nombres únicos, etc. No necesita setter. Simplifica el razonamiento sobre el código.</p>
        </div>
      </div>
      
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Getter (Método de Lectura)</h4>
          <p>Retorna el valor actual de un atributo privado. Por convención, el nombre es <code>get</code> seguido del nombre del atributo con primera letra mayúscula. Ej: <code>getNombre()</code>, <code>getEdad()</code>.</p>
        </div>
        <div class="card-teorico">
          <h4>Setter (Método de Escritura)</h4>
          <p>Modifica el valor de un atributo privado. Por convención, el nombre es <code>set</code> seguido del nombre del atributo. Incluye validaciones para garantizar que el nuevo valor es válido antes de asignarlo.</p>
        </div>
        <div class="card-teorico">
          <h4>Atributos Privados</h4>
          <p>Usa <code>private</code> para los atributos de datos. Esto obliga a otros a usar getters/setters, permitiéndote controlar el acceso y validar. Nunca hagas públicos los atributos de datos.</p>
        </div>
      </div>

      <h3>Ejemplo: Validación en Setters</h3>
      <p><strong>Explicación:</strong> Esta clase demuestra cómo usar setters para validar datos. El setter de saldo rechaza valores negativos. Los métodos <code>depositar()</code> y <code>retirar()</code> también incluyen validaciones. Todos modific el estado interno de forma controlada.</p>
      <pre><code class="language-java">// Clase que representa una cuenta bancaria
public class CuentaBancaria {
    // Atributo private: nombre del titular
    private String titular;
    // Atributo private: saldo actual de la cuenta
    private double saldo;

    // Constructor: inicializa la cuenta con titular y saldo inicial
    public CuentaBancaria(String titular, double saldoInicial) {
        // Asigna el titular
        this.titular = titular;
        // Valida que el saldo inicial no sea negativo usando Math.max(0, valor)
        this.saldo = Math.max(0, saldoInicial); // no negativo
    }

    // Getter: retorna el saldo actual
    public double getSaldo() {
        // Retorna el saldo sin modificación
        return saldo;
    }

    // Setter con validación: modifica el saldo de forma segura
    public void setSaldo(double nuevoSaldo) {
        // Valida que el nuevo saldo sea no-negativo
        if (nuevoSaldo >= 0) {
            // Si es válido, asigna el nuevo saldo
            this.saldo = nuevoSaldo;
        } else {
            // Si es inválido, imprime un mensaje de error
            System.out.println("Error: el saldo no puede ser negativo");
        }
    }

    // Método que realiza un depósito validado
    public void depositar(double cantidad) {
        // Valida que la cantidad sea positiva
        if (cantidad > 0) {
            // Si es válida, suma la cantidad al saldo actual
            saldo += cantidad;
            // Imprime confirmación del depósito
            System.out.println("Depósito de $" + cantidad + " exitoso. Saldo: $" + saldo);
        }
    }

    // Método que realiza un retiro validado
    public void retirar(double cantidad) {
        // Valida que la cantidad sea positiva Y que haya fondos suficientes
        if (cantidad > 0 && cantidad <= saldo) {
            // Si es válido, resta la cantidad del saldo
            saldo -= cantidad;
            // Imprime confirmación del retiro
            System.out.println("Retiro de $" + cantidad + " exitoso. Saldo: $" + saldo);
        } else {
            // Si no es válido, imprime un mensaje de error
            System.out.println("Operación rechazada: fondos insuficientes o cantidad inválida");
        }
    }
}
</code></pre>

      <h3>Uso de Getters y Setters</h3>
      <pre><code class="language-java">CuentaBancaria miCuenta = new CuentaBancaria("Juan", 1000);

// Leer atributo (getter)
System.out.println("Saldo: $" + miCuenta.getSaldo()); // Saldo: $1000

// Modificar atributo (setter)
miCuenta.setSaldo(1500); // Saldo válido, se acepta
miCuenta.setSaldo(-500); // Saldo inválido, se rechaza (error)

// Usar métodos que modifican atributos
miCuenta.depositar(250);  // Depósito de $250 exitoso. Saldo: $1250
miCuenta.retirar(100);    // Retiro de $100 exitoso. Saldo: $1150
miCuenta.retirar(2000);   // Error: fondos insuficientes
</code></pre>

      <h3>Validación en Setters</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Validación por Rango</h4>
          <p>Verifica que valores numéricos estén dentro de un rango válido. Ejemplo: edad entre 0 y 150, precio mayor a 0. Usa condicionales: <code>if (valor < minimo || valor > maximo) throw new Exception()</code>.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Validación de Null</h4>
          <p>Para atributos String o de referencia, valida que no sean null. Usa <code>if (valor == null) throw new NullPointerException()</code> o Java 16+: <code>Objects.requireNonNull(valor)</code>. Previene errores posteriores.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Validación de Formato</h4>
          <p>Para strings, valida formato con regex o métodos. Ejemplo: emails con patrón, teléfonos con longitud. Garantiza que los datos cumplen estructura esperada antes de guardarlos.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Excepciones Descriptivas</h4>
          <p>Lanza excepciones con mensajes claros. Ejemplo: <code>throw new IllegalArgumentException("Edad debe ser entre 0 y 150")</code>. El mensaje ayuda a los desarrolladores a entender y arreglar el problema rápido.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Validación Combinada</h4>
          <p>Combina múltiples validaciones cuando sea necesario. Valida primero lo más crítico. Usa métodos privados para encapsular lógica de validación compleja.</p>
        </div>
      </div>
    </section>

    <section id="mutabilidad">
      <h2>Mutabilidad e Inmutabilidad</h2>
      <p>La mutabilidad define si el estado de un objeto puede cambiar después de su creación. Es un concepto crucial para escribir código seguro, especialmente en programas multi-threaded.</p>

      <h3>Objetos Mutables vs Inmutables</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Objeto Mutable</h4>
          <p>Su estado puede cambiar después de crearlo. Ejemplo: <code>CuentaBancaria</code> (el saldo puede cambiar), <code>ArrayList</code> (se pueden agregar/eliminar elementos). Más flexible, pero requiere más cuidado con la sincronización.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Objeto Inmutable</h4>
          <p>Su estado no puede cambiar después de crearlo. Ejemplo: <code>String</code>, <code>Integer</code> en Java. Más seguro en multi-threading. Si necesitas "cambiar" su estado, creas un nuevo objeto con los nuevos valores.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Crear una Clase Inmutable</h4>
          <p><strong>Pasos:</strong> 1) Declara la clase <code>final</code>. 2) Todos los atributos <code>private final</code>. 3) Inicializa en constructor, sin setters. 4) Retorna copias defensivas en getters para objetos mutables. 5) Override <code>hashCode()</code> y <code>equals()</code>.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Ventajas de Inmutabilidad</h4>
          <p><strong>1) Seguridad en threads:</strong> No necesita sincronización. <strong>2) Cache seguro:</strong> Se puede guardar sin preocupaciones. <strong>3) Simplicidad:</strong> Estado no cambia, fácil de razonar. <strong>4) Hash seguro:</strong> hashCode() nunca cambia.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Desventajas de Inmutabilidad</h4>
          <p><strong>1) Uso de memoria:</strong> Crear nuevo objeto por cada cambio consume más memoria. <strong>2) Menos flexible:</strong> No puedes "actualizar" propiedades, debes recrear. <strong>3) Complejidad:</strong> Requiere copias defensivas, lo que puede ser tedioso.</p>
        </div>
      </div>

      <h3>Ejemplo: Clase Inmutable</h3>
      <p><strong>Explicación:</strong> Clase <code>Fecha</code> es inmutable: sus atributos son <code>final</code> y no hay setters. Una vez creada, no puede cambiar. Si necesitas "modificar", creas una nueva instancia. Demuestra seguridad y previsibilidad del código.</p>
      <pre><code class="language-java">// Clase Inmutable: no puede cambiar después de crearse
public final class Fecha {  // final: no puede heredarse (parte de ser inmutable)
    // Atributos final: no pueden cambiar después de asignarse
    private final int dia;
    // Atributo final: no puede cambiar
    private final int mes;
    // Atributo final: no puede cambiar
    private final int anio;

    // Constructor: único lugar donde se asignan valores a atributos final
    public Fecha(int dia, int mes, int anio) {
        // Valida que la fecha sea válida antes de asignar
        if (!esValida(dia, mes, anio)) {
            // Lanza excepción si los datos son inválidos
            throw new IllegalArgumentException("Fecha inválida");
        }
        // Asigna día (solo se puede hacer en constructor o inicializador)
        this.dia = dia;
        // Asigna mes
        this.mes = mes;
        // Asigna año
        this.anio = anio;
    }

    // Getters: retornan los valores, pero no hay setters (inmutabilidad)
    public int getDia() { return dia; }
    public int getMes() { return mes; }
    public int getAnio() { return anio; }

    // Método privado: valida si una fecha es válida
    private static boolean esValida(int d, int m, int a) {
        // Verifica mes entre 1 y 12, día entre 1 y 31, año positivo
        return m >= 1 && m <= 12 && d >= 1 && d <= 31 && a > 0;
    }

    // Si necesitas "cambiar" la fecha, creas una NUEVA instancia (no modificas)
    public Fecha agregarDias(int dias) {
        // Calcula el nuevo día (lógica simplificada)
        int nuevoDia = dia + dias;
        int nuevoMes = mes;
        int nuevoAnio = anio;
        // ajustar mes y año si es necesario...
        // Retorna una NUEVA instancia de Fecha con los nuevos valores
        return new Fecha(nuevoDia, nuevoMes, nuevoAnio);
    }

    // Sobrescribe toString para representación legible
    @Override
    public String toString() {
        // Retorna la fecha formateada
        return dia + "/" + mes + "/" + anio;
    }

    // Sobrescribe equals para comparar fechas lógicamente
    @Override
    public boolean equals(Object obj) {
        // Si es el mismo objeto en memoria, son iguales
        if (this == obj) return true;
        // Si el otro objeto no es instancia de Fecha, no son iguales
        if (!(obj instanceof Fecha)) return false;
        // Castea el objeto a Fecha para acceder a sus atributos
        Fecha otra = (Fecha) obj;
        // Compara día, mes y año
        return dia == otra.dia && mes == otra.mes && anio == otra.anio;
    }

    // Sobrescribe hashCode: importante cuando usas Fecha en HashSet o HashMap
    @Override
    public int hashCode() {
        // Calcula hash basado en los atributos
        return java.util.Objects.hash(dia, mes, anio);
    }
}

// Uso de la clase Inmutable
public class Main {
    // Método main: punto de entrada
    public static void main(String[] args) {
        // Crea una fecha inmutable: 15/6/2024
        Fecha f1 = new Fecha(15, 6, 2024);
        // Imprime la fecha
        System.out.println(f1);  // Salida: 15/6/2024
        
        // NO puedo hacer f1.setDia(20) - no existe setter (porque es inmutable)
        // Si necesito otra fecha, creo una NUEVA instancia llamando agregarDias()
        // Este método retorna una nueva instancia, NO modifica f1
        Fecha f2 = f1.agregarDias(5);  // retorna nueva instancia
        // Imprime la nueva fecha
        System.out.println(f2);  // Salida: 20/6/2024
        // Imprime f1 para verificar que no cambió
        System.out.println(f1);  // Salida: 15/6/2024 (f1 sigue siendo la misma)
        
        // Esto es inmutabilidad: el objeto no puede cambiar después de crearse
        // Es seguro en multi-threading y fácil de predecir
    }
}
</code></pre>
    </section>

    <section id="metodos">
      <h2>Manipulación de Métodos</h2>
      <p>Los métodos son funciones que definen el comportamiento de un objeto. Se invocan usando la notación de punto: <code>objeto.metodo()</code>. Un buen diseño de métodos es clave para crear código mantenible, reutilizable y fácil de entender.</p>

      <h3>Clasificación de Métodos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Métodos sin Retorno (void)</h4>
          <p>Ejecutan una acción pero no retornan valor. Sintaxis: <code>public void nombreMetodo() { ... }</code>. Se usan para modificar el estado interno o realizar operaciones sin resultado. Ejemplo: <code>depositar()</code>, <code>saludar()</code>.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Métodos con Retorno</h4>
          <p>Ejecutan cálculos/consultas y devuelven un resultado. Especifican el tipo: <code>int</code>, <code>String</code>, <code>boolean</code>, objetos, etc. Sintaxis: <code>public TipoRetorno nombreMetodo() { return valor; }</code>. Ejemplo: <code>calcularSaldo()</code>.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Métodos con Parámetros</h4>
          <p>Reciben uno o más argumentos para procesarlos. Aumentan la reutilización: mismo método, diferentes datos. Sintaxis: <code>public void metodo(Tipo param1, Tipo param2) { ... }</code>. Los parámetros son locales al método.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Métodos Privados</h4>
          <p>Usa <code>private</code> para métodos que solo la clase usa internamente. Encapsulan lógica compleja y detalles de implementación. No son parte de la interfaz pública. Facilita cambios internos sin afectar otros códigos.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Métodos Estáticos</h4>
          <p>Declarados con <code>static</code>. Pertenecen a la clase, no a instancias. Se invocan en la clase: <code>NombreClase.metodo()</code>. Útiles para utilidades: <code>Math.max()</code>, <code>System.out.println()</code>. No pueden acceder a atributos de instancia.</p>
        </div>
      </div>
      
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Métodos sin Retorno (void)</h4>
          <p>Ejecutan una acción pero no devuelven un resultado. Ejemplo: <code>depositar()</code>, <code>saludar()</code>. Se usan para modificar el estado o realizar operaciones sin necesidad de valores de salida.</p>
        </div>
        <div class="card-teorico">
          <h4>Métodos con Retorno</h4>
          <p>Ejecutan una acción y devuelven un valor. El tipo de retorno especifica qué tipo de dato retorna: <code>int</code>, <code>String</code>, <code>boolean</code>, etc. Se usan para cálculos, búsquedas y consultas.</p>
        </div>
        <div class="card-teorico">
          <h4>Métodos con Parámetros</h4>
          <p>Reciben uno o más argumentos para procesar. Los parámetros permiten que un método se comporte diferente según los datos que reciba. Facilita la reutilización de código.</p>
        </div>
      </div>

      <h3>Estructura de un Método</h3>
      <pre><code class="language-java">modificador tipoRetorno nombreMetodo(parametro1, parametro2, ...) {
    // cuerpo del método
    return valor; // si tipoRetorno != void
}

// Ejemplos
public void saludar(String nombre) {
    System.out.println("¡Hola, " + nombre + "!");
}

public int sumar(int a, int b) {
    return a + b;
}

public boolean esAdulto(int edad) {
    return edad >= 18;
}

public String obtenerInfo() {
    return "Información del objeto";
}
</code></pre>

      <h3>Invocación de Métodos</h3>
      <p><strong>Explicación:</strong> Esta clase demuestra diferentes tipos de métodos: sin parámetros ni retorno (<code>saludar()</code>), con parámetros sin retorno (<code>cumpleanios()</code>), con retorno (<code>esAdulto()</code>), y con parámetros y retorno (<code>presentarse()</code>).</p>
      <pre><code class="language-java">// Clase que demuestra diferentes tipos de métodos
public class Persona {
    // Atributo private: nombre
    private String nombre;
    // Atributo private: edad
    private int edad;

    // Constructor: inicializa la persona
    public Persona(String nombre, int edad) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
    }

    // Método 1: Sin parámetros, sin retorno (void)
    // Propósito: ejecutar una acción sin datos de entrada ni salida
    public void saludar() {
        // Imprime un saludo usando el nombre de la persona
        System.out.println("Hola, soy " + nombre);
    }

    // Método 2: Sin parámetros, sin retorno (void)
    // Propósito: modificar el estado interno (incrementar edad)
    public void cumpleanios() {
        // Incrementa la edad en 1
        edad++;
        // Imprime el nuevo estado
        System.out.println(nombre + " ahora tiene " + edad + " años");
    }

    // Método 3: Sin parámetros, con retorno booleano
    // Propósito: consultar si la persona cumple una condición
    public boolean esAdulto() {
        // Retorna true si edad es 18 o más, false si no
        return edad >= 18;
    }

    // Método 4: Con parámetros (String) y con retorno (String)
    // Propósito: usar datos externos y retornar un resultado construido
    public String presentarse(String saludo) {
        // Retorna un string que combina el saludo con información de la persona
        return saludo + ", me llamo " + nombre + " y tengo " + edad + " años";
    }
}

// Clase de uso: demuestra cómo invocar los diferentes métodos
public class Main {
    // Método main: punto de entrada
    public static void main(String[] args) {
        // Crea una instancia de Persona: Ana, 25 años
        Persona p = new Persona("Ana", 25);

        // Invoca método 1: sin parámetros, sin retorno
        // La acción se ejecuta (imprime) pero no retorna nada
        p.saludar();                           // Salida: Hola, soy Ana
        
        // Invoca método 2: sin parámetros, sin retorno
        // Modifica el estado (incrementa edad) y imprime
        p.cumpleanios();                       // Salida: Ana ahora tiene 26 años
        
        // Invoca método 3: sin parámetros, con retorno booleano
        // Retorna un valor booleano que imprimimos
        System.out.println(p.esAdulto());      // Salida: true (26 >= 18)
        
        // Invoca método 4: con parámetro String, con retorno String
        // Pasa "Buenos días" como argumento, retorna un string que imprimimos
        System.out.println(p.presentarse("Buenos días")); 
        // Salida: Buenos días, me llamo Ana y tengo 26 años
    }
}
</code></pre>
    </section>

    <section id="buenas-practicas-metodos">
      <h2>Buenas Prácticas en Métodos</h2>
      <p>El diseño de métodos es crítico para la calidad del código. Métodos bien diseñados son fáciles de entender, probar, mantener y reutilizar.</p>

      <h3>Principios de Buen Diseño de Métodos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Responsabilidad Única</h4>
          <p><strong>Single Responsibility Principle (SRP):</strong> Cada método debe hacer una sola cosa bien. Si un método hace múltiples cosas, divídelo en varios métodos. Un método con una responsabilidad clara es fácil de entender, probar y mantener.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Nombres Descriptivos</h4>
          <p>Nombres deben ser verbos que describan la acción: <code>calcular</code>, <code>validar</code>, <code>obtener</code>, <code>establecer</code>. Evita nombres genéricos como <code>procesar</code> o <code>hacer</code>. Un buen nombre es documentación en sí misma; debe ser auto-explicativo.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Parámetros Mínimos</h4>
          <p>Limita el número de parámetros (idealmente ≤ 3). Muchos parámetros hace métodos confusos y difíciles de invocar. Si necesitas muchos, agrúpalos en un objeto: <code>metodo(ConfiguracionObjeto config)</code> en lugar de <code>metodo(int a, int b, int c, ...)</code>.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Sin Efectos Secundarios</h4>
          <p>Métodos no deberían modificar estado global o externo inesperadamente. Si un método dice "obtener", debería solo retornar sin cambiar nada. Si modifica estado, el nombre debe indicarlo: <code>depositar()</code> en lugar de solo <code>obtenerSaldo()</code>.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Documentación con Javadoc</h4>
          <p>Documenta métodos públicos con Javadoc: <code>/** ... @param ... @return ... @throws ... */</code>. Especifica qué hace, parámetros, retorno y excepciones. Herramientas generan documentación automáticamente. Facilita uso correcto por otros desarrolladores.</p>
        </div>
      </div>

      <h3>Ejemplo: Método Bien Diseñado</h3>
      <p><strong>Explicación:</strong> Este ejemplo muestra cómo diseñar un método de forma profesional: con validaciones claras, documentación Javadoc, responsabilidad única y métodos auxiliares privados que encapsulan complejidad.</p>
      <pre><code class="language-java">/**
 * Método bien documentado con Javadoc
 * Valida y procesa un depósito en la cuenta.
 * 
 * @param monto la cantidad a depositar, debe ser mayor a 0
 * @throws IllegalArgumentException si monto es negativo o cero
 * @return true si el depósito fue exitoso, false en caso contrario
 */
public boolean procesarDeposito(double monto) {
    // Una responsabilidad clara: procesar depósito
    // Valida que el monto sea positivo
    if (monto <= 0) {
        // Lanza una excepción con mensaje descriptivo
        throw new IllegalArgumentException("Monto debe ser positivo");
    }
    
    // Si es válido, suma el monto al saldo actual
    saldo += monto;
    // Llama a método privado auxiliar para encapsular lógica de registro
    registrarTransacción("Depósito", monto);
    // Retorna true indicando éxito
    return true;
}

/**
 * Método privado auxiliar: encapsula la lógica de registrar transacciones.
 * No forma parte de la interfaz pública.
 * 
 * @param tipo el tipo de transacción (ej: "Depósito", "Retiro")
 * @param monto el monto de la transacción
 */
private void registrarTransacción(String tipo, double monto) {
    // Imprime información de transacción con timestamp (hora actual)
    System.out.println("[" + java.time.LocalDateTime.now() + "] " + tipo + ": $" + monto);
}
</code></pre>

      <h3>Patrones Comunes de Métodos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Constructor</h4>
          <p><code>public NombreClase(...)</code>. Método especial que inicializa objetos. Mismo nombre que la clase. Ejecuta automáticamente con <code>new</code>. Encapsula lógica de inicialización.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Getter</h4>
          <p><code>public Tipo get NombreAtributo()</code>. Retorna valor de atributo privado. Lectura segura. Por convención: <code>getNombre()</code>, <code>getEdad()</code>. Puede validar o retornar copia.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Setter</h4>
          <p><code>public void setNombreAtributo(Tipo valor)</code>. Modifica atributo con validación. Escritura segura. Por convención: <code>setNombre()</code>. Lanza excepciones si datos inválidos.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>toString()</h4>
          <p><code>public String toString()</code>. Retorna representación en texto del objeto. Útil para debugging y logging. Sobrescribe el método de <code>Object</code>. Ejemplo: <code>"Persona{nombre='Ana', edad=28}"</code>.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>equals()</h4>
          <p><code>public boolean equals(Object obj)</code>. Compara si dos objetos son iguales lógicamente. Sobrescribe el método de <code>Object</code>. Importante para colecciones: List, Set, Map. Siempre paired con <code>hashCode()</code>.</p>
        </div>
      </div>
    </section>

      <h2>Ejercicio Práctico</h2>

      <h3>Clase Automóvil con Métodos</h3>
      <p><strong>Enunciado:</strong> Crea una clase <code>Automovil</code> con marca, modelo, año y velocidad actual. Implementa métodos para acelerar, frenar, obtener velocidad máxima según el modelo.</p>

      <div class="solution">
        <h3>Solución Compilable</h3>
        <pre><code class="language-java">// Clase Automóvil
class Automovil {
    private String marca, modelo;
    private int anio;
    private double velocidad;
    private double velMax;

    // Constructor
    public Automovil(String marca, String modelo, int anio, double velMax) {
        this.marca = marca;
        this.modelo = modelo;
        this.anio = anio;
        this.velocidad = 0;
        this.velMax = velMax;
    }

    // Acelerar - no puede exceder velocidad máxima
    public void acelerar(double incremento) {
        velocidad = Math.min(velocidad + incremento, velMax);
    }

    // Frenar - no puede ser negativa
    public void frenar(double decremento) {
        velocidad = Math.max(velocidad - decremento, 0);
    }

    public double getVelocidad() { return velocidad; }

    @Override
    public String toString() {
        return marca + " " + modelo + " (" + anio + ") - Vel: " + velocidad + " km/h";
    }
}

// Programa Principal
public class Main {
    public static void main(String[] args) {
        // Crear automóvil con velocidad máxima de 200 km/h
        Automovil auto = new Automovil("Toyota", "Sedan", 2023, 200);

        // Acelerar
        auto.acelerar(50);   // 50 km/h
        System.out.println(auto);

        auto.acelerar(100);  // 150 km/h
        System.out.println(auto);

        auto.acelerar(100);  // Intenta 250, pero máximo es 200
        System.out.println(auto);

        // Frenar
        auto.frenar(30);     // 170 km/h
        System.out.println(auto);
    }
}
</code></pre>
      </div>
    </section>

    <h3>Cards de Refuerzo: Instanciación y Manipulación</h3>
    <div class="cards-grid-teoricos">
      <div class="card-teorico">
        <h4>Operador new</h4>
        <p>Crea una nueva instancia de una clase en memoria. Sintaxis: <code>new NombreClase(argumentos)</code>. Invoca automáticamente el constructor que coincida con los argumentos proporcionados.</p>
      </div>
      <div class="card-teorico">
        <h4>Constructor</h4>
        <p>Método especial que inicializa un objeto. Tiene el mismo nombre que la clase. Se ejecuta automáticamente al crear una instancia. Puede validar datos y establecer valores iniciales.</p>
      </div>
      <div class="card-teorico">
        <h4>Sobrecarga de Constructores</h4>
        <p>Múltiples constructores con diferentes firmas. Java elige el correcto según los argumentos. Permite flexibilidad en cómo crear objetos con distintos conjuntos de datos iniciales.</p>
      </div>
      <div class="card-teorico">
        <h4>Getters y Setters</h4>
        <p>Métodos públicos para acceder (get) y modificar (set) atributos privados. Los setters pueden validar datos. Es la forma encapsulada y segura de acceder a los datos de un objeto.</p>
      </div>
      <div class="card-teorico">
        <h4>Referencias de Objetos</h4>
        <p>Las variables que guardan objetos son referencias (apuntadores) a ubicaciones en memoria, no copias. Múltiples variables pueden apuntar al mismo objeto. Asignar a otra variable copia la referencia, no el objeto.</p>
      </div>
      <div class="card-teorico">
        <h4>Estado Independiente</h4>
        <p>Cada instancia tiene su propio estado (valores de atributos) independiente. Cambiar un atributo en una instancia no afecta a otras, aunque sean de la misma clase.</p>
      </div>
    </div>

    <h3>Buenas Prácticas</h3>
    <div class="info-box">
      <ol>
        <li><strong>Usa constructores para inicializar:</strong> establece valores iniciales válidos en el constructor, no después de crear el objeto.</li>
        <li><strong>Valida en constructores y setters:</strong> asegúrate de que los datos sean válidos antes de asignarlos. Lanza excepciones si es necesario.</li>
        <li><strong>Mantén atributos privados:</strong> siempre usa <code>private</code> para atributos de datos; proporciona getters/setters públicos para acceso controlado.</li>
        <li><strong>Nombra getters/setters convencionalmente:</strong> usa <code>getNombre()</code>, <code>setNombre()</code> para que otros programadores reconozcan fácilmente estos métodos.</li>
        <li><strong>Evita lógica compleja en getters/setters:</strong> estos métodos deben ser simples. Si necesitas lógica compleja, crea métodos separados.</li>
        <li><strong>Proporciona constructores útiles:</strong> crea múltiples constructores (sobrecarga) para permitir diferentes formas de crear objetos con datos iniciales relevantes.</li>
        <li><strong>Usa <code>this</code> explícitamente en constructores:</strong> especifica <code>this.atributo = parametro</code> para claridad al leer el código.</li>
      </ol>
    </div>

    <section id="videos-educativos">
      <h2>Videos Educativos</h2>
      <div class="videos-grid">
        <div class="video-container">
          <h3>Curso Java desde cero - Instanciación de Objetos</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/54- Curso Java desde cero- Declaración, instanciación e inicialización de un obj.mp4" type="video/mp4">
              Tu navegador no soporta la reproducción de video. <a href="videos/54- Curso Java desde cero- Declaración, instanciación e inicialización de un obj.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Aprende cómo declarar, instanciar e inicializar objetos en Java desde cero.</p>
        </div>
        <div class="video-container">
          <h3>POO - Ejemplo Práctico en Java</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/POO 2 - Ejemplo práctico (Clases, objetos, atributos y métodos). - Java.mp4" type="video/mp4">
              Tu navegador no soporta la reproducción de video. <a href="videos/POO 2 - Ejemplo práctico (Clases, objetos, atributos y métodos). - Java.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Ejemplo práctico completo de cómo trabajar con clases, objetos, atributos y métodos en Java.</p>
        </div>
      </div>
    </section>

    <p class="muted">Recursos adicionales: <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html" target="_blank" rel="noopener">Classes and Objects (Oracle)</a> • <a href="https://www.geeksforgeeks.org/constructors-in-java/" target="_blank" rel="noopener">Constructors in Java (GeeksforGeeks)</a></p>

    <p><a href="index.html">Volver al inicio</a></p>
  </main>

  <footer class="site-footer">
    <p>&copy; Página web POO 2026 - Todos los derechos reservados.</p>
  </footer>
  
  <!-- Botones de navegación profesional -->
  <div class="nav-buttons-container">
    <button class="nav-button top" data-tooltip="Ir al principio" onclick="scrollToTop()">↑</button>
    <button class="nav-button" data-tooltip="Subir página" onclick="scrollUp()">↑</button>
    <button class="nav-button" data-tooltip="Bajar página" onclick="scrollDown()">↓</button>
    <button class="nav-button bottom" data-tooltip="Ir al final" onclick="scrollToBottom()">↓</button>
  </div>
  
  <script src="js/main.js" defer></script>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    
    function scrollUp() {
      window.scrollBy({ top: -window.innerHeight * 0.8, behavior: 'smooth' });
    }
    
    function scrollDown() {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
    }
  </script>
</body>
</html>
