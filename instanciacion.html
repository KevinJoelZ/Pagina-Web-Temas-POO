<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Instanciaci√≥n de Objetos - POO</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <header class="site-header">
    <nav class="navbar">
      <div class="brand"><a href="index.html">POO</a></div>
      <ul class="nav-links">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="fundamentos.html">Fundamentos</a></li>
        <li><a href="instanciacion.html">Instanciaci√≥n</a></li>
        <li><a href="herencia.html">Herencia</a></li>
        <li><a href="ejercicios.html">Ejercicios</a></li>
        <li><a href="ejercicios-en-clase.html">Ejercicios en Clase</a></li>
        <li><a href="ejercicios-temas-poo.html">Ejercicios Temas POO</a></li>
        <li><a href="trabajos-autonomos.html">Trabajos Aut√≥nomos</a></li>
        <li><a href="clase-practica.html">Clase Pr√°ctica</a></li>
        <li><a href="https://drive.google.com/drive/folders/175wdD0Z5zasjrHCy6rzqJpAT-K2fHqBW?hl=es" target="_blank" class="nav-videos">üé¨ Videos</a></li>
      </ul>
    </nav>
  </header>

  <main class="content">
    <h1>Instanciaci√≥n de Objetos y Manipulaci√≥n de Atributos y M√©todos</h1>

    <p>En esta p√°gina aprender√°s c√≥mo crear instancias de objetos en Java, c√≥mo manipular sus atributos (propiedades) y c√≥mo invocar sus m√©todos. La instanciaci√≥n es el proceso fundamental que convierte una clase (plantilla) en objetos reales con los que trabajamos en nuestros programas.</p>

    <section id="que-es-instanciacion">
      <h2>¬øQu√© es la Instanciaci√≥n?</h2>
      <p><strong>Definici√≥n:</strong> La instanciaci√≥n es el proceso de crear un objeto concreto a partir de una clase. Una clase es un plano o plantilla; una instancia es un objeto real en memoria con su propio estado (valores de atributos). Cada instancia es independiente de las dem√°s, aunque comparten la misma estructura definida en la clase.</p>

      <h3>Clase vs Instancia</h3>
      <ul>
        <li><strong>Clase:</strong> es el tipo, el molde, la especificaci√≥n de qu√© atributos y m√©todos tendr√° cada objeto.</li>
        <li><strong>Instancia (objeto):</strong> es una copia concreta de esa clase con valores espec√≠ficos para sus atributos.</li>
      </ul>

      <div class="figure">
        <svg class="svg-illustration" viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Clase vs Instancia">
          <rect x="20" y="20" width="240" height="160" rx="10" fill="#eef6ff" stroke="#48bb78" stroke-width="2"/>
          <text x="40" y="50" font-size="16" font-weight="700" fill="#0f1724">Clase: Persona</text>
          <text x="40" y="75" font-size="13" fill="#374151">atributos:</text>
          <text x="50" y="95" font-size="12" fill="#374151">- nombre: String</text>
          <text x="50" y="110" font-size="12" fill="#374151">- edad: int</text>
          <text x="50" y="125" font-size="12" fill="#374151">- correo: String</text>
          <text x="40" y="155" font-size="12" fill="#6b7280" font-style="italic">Plantilla/Molde</text>

          <rect x="340" y="20" width="150" height="70" rx="8" fill="#fff7ed" stroke="#fbbf24" stroke-width="2"/>
          <text x="360" y="45" font-size="14" font-weight="700" fill="#0f1724">Ana</text>
          <text x="360" y="62" font-size="12" fill="#374151">edad: 28</text>
          <text x="360" y="77" font-size="12" fill="#374151">correo: ana@email.com</text>

          <rect x="340" y="110" width="150" height="70" rx="8" fill="#fff7ed" stroke="#fbbf24" stroke-width="2"/>
          <text x="360" y="135" font-size="14" font-weight="700" fill="#0f1724">Luis</text>
          <text x="360" y="152" font-size="12" fill="#374151">edad: 35</text>
          <text x="360" y="167" font-size="12" fill="#374151">correo: luis@email.com</text>

          <path d="M260 50 L340 50" stroke="#9aaed0" stroke-width="2" marker-end="url(#arrowhead)"/>
          <path d="M260 140 L340 140" stroke="#9aaed0" stroke-width="2" marker-end="url(#arrowhead)"/>

          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#9aaed0"/>
            </marker>
          </defs>

          <text x="280" y="40" font-size="11" fill="#6b7280">instancia 1</text>
          <text x="280" y="135" font-size="11" fill="#6b7280">instancia 2</text>
        </svg>
      </div>

      <h3>¬øC√≥mo crear una instancia?</h3>
      <p>En Java, usamos la palabra clave <code>new</code> seguida del constructor de la clase para crear una instancia:</p>
      <pre><code class="language-java">// Sintaxis general
TipoClase nombreVariable = new TipoClase(argumentosDelConstructor);

// Ejemplo
Persona ana = new Persona("Ana", 28, "ana@email.com");
Persona luis = new Persona("Luis", 35, "luis@email.com");
</code></pre>

      <p>Cada variable (<code>ana</code>, <code>luis</code>) apunta a una instancia diferente en memoria con su propio estado.</p>

      <h3>Conceptos Clave en Instanciaci√≥n</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Operador new</h4>
          <p>Palabra clave que asigna memoria en el heap para el nuevo objeto. Invoca autom√°ticamente el constructor apropiado. <strong>Siempre</strong> debes usar <code>new</code> para crear objetos (excepto String que tiene casos especiales).</p>
        </div>
        <div class="card-profesional-green">
          <h4>Referencia vs Objeto</h4>
          <p>La variable que declares es una <strong>referencia</strong> (apuntador) al objeto, no el objeto en s√≠. M√∫ltiples referencias pueden apuntar al mismo objeto. Asignar una variable a otra copia la referencia, no clona el objeto.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Null: Referencia Vac√≠a</h4>
          <p>Una variable de referencia puede contener <code>null</code>, lo que significa "no apunta a nada". Acceder a m√©todos/atributos de <code>null</code> causa <code>NullPointerException</code>. Siempre valida antes de usar referencias.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Independencia de Estado</h4>
          <p>Cada instancia tiene su propio estado (valores de atributos) completamente independiente. Cambiar un atributo en una instancia no afecta a otras, aunque sean de la misma clase.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Inicializaci√≥n en Constructor</h4>
          <p>El constructor ejecuta c√≥digo de inicializaci√≥n cuando se crea el objeto. Es el lugar ideal para validar datos, establecer valores iniciales v√°lidos y garantizar que el objeto nace en un estado consistente.</p>
        </div>
      </div>
    </section>

    <section id="constructores">
      <h2>Constructores: Inicializando Objetos</h2>
      <p><strong>Definici√≥n:</strong> Un constructor es un m√©todo especial que se ejecuta cuando creas una instancia. Se usa para inicializar el estado del objeto. Todo constructor tiene el mismo nombre que la clase.</p>

      <h3>Tipos de Constructores</h3>
      
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Constructor por Defecto (sin argumentos)</h4>
          <p>Si no defines ning√∫n constructor, Java proporciona uno autom√°ticamente que inicializa atributos con valores por defecto (0, null, false, etc.). Puedes definir expl√≠citamente uno vac√≠o para mayor control.</p>
        </div>
        <div class="card-teorico">
          <h4>Constructor Parametrizado</h4>
          <p>Acepta par√°metros para inicializar atributos con valores espec√≠ficos. Es lo m√°s com√∫n. Permite crear objetos con estado v√°lido desde el inicio.</p>
        </div>
        <div class="card-teorico">
          <h4>Sobrecarga de Constructores</h4>
          <p>Puedes definir m√∫ltiples constructores con diferentes firmas (diferentes n√∫meros o tipos de par√°metros). Java elige el correcto seg√∫n los argumentos que pases al usar <code>new</code>.</p>
        </div>
      </div>

      <h3>Ejemplo: Clase con Constructores</h3>
      <p><strong>Explicaci√≥n:</strong> Esta clase demuestra diferentes tipos de constructores. El constructor vac√≠o (<code>por defecto</code>) inicializa con valores por defecto. El constructor parametrizado es el m√°s com√∫n. El constructor alternativo usa <code>this()</code> para delegar a otro constructor (delegaci√≥n), evitando c√≥digo duplicado.</p>
      <pre><code class="language-java">// Clase que demostra diferentes constructores
public class Estudiante {
    // Atributo private: nombre del estudiante
    private String nombre;
    // Atributo private: edad del estudiante
    private int edad;
    // Atributo private: promedio acad√©mico
    private double promedio;

    // Constructor 1: Constructor vac√≠o (sin argumentos)
    // Se ejecuta cuando se crea: new Estudiante()
    public Estudiante() {
        // Inicializa nombre con valor por defecto
        this.nombre = "Desconocido";
        // Inicializa edad en 0
        this.edad = 0;
        // Inicializa promedio en 0.0
        this.promedio = 0.0;
    }

    // Constructor 2: Constructor parametrizado (el m√°s com√∫n)
    // Se ejecuta cuando se crea: new Estudiante("Ana", 20, 85.5)
    public Estudiante(String nombre, int edad, double promedio) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
        // Valida que el promedio est√© entre 0 y 100 usando Math.max y Math.min
        // Math.max(0, valor) asegura que no sea menor a 0
        // Math.min(100, resultado) asegura que no sea mayor a 100
        this.promedio = Math.max(0, Math.min(100, promedio)); // validaci√≥n: 0-100
    }

    // Constructor 3: Constructor alternativo (menos par√°metros)
    // Se ejecuta cuando se crea: new Estudiante("Ana", 20)
    public Estudiante(String nombre, int edad) {
        // Delega a otro constructor usando this()
        // this(nombre, edad, 0.0) llama al constructor parametrizado
        // Evita duplicaci√≥n de c√≥digo de validaci√≥n
        this(nombre, edad, 0.0); // delegar a otro constructor
    }

    // Getters: m√©todos p√∫blicos para leer atributos privados
    public String getNombre() { return nombre; }
    // Getter para edad
    public int getEdad() { return edad; }
    // Getter para promedio
    public double getPromedio() { return promedio; }

    // Setter: m√©todo p√∫blico para modificar el promedio con validaci√≥n
    public void setPromedio(double promedio) {
        // Valida que el promedio est√© entre 0 y 100
        this.promedio = Math.max(0, Math.min(100, promedio));
    }
}
</code></pre>

      <h3>Usando los Constructores</h3>
      <pre><code class="language-java">// Crear instancia con constructor vac√≠o
Estudiante est1 = new Estudiante();

// Crear instancia con par√°metros
Estudiante est2 = new Estudiante("Carlos", 20, 85.5);

// Crear instancia con constructor alternativo
Estudiante est3 = new Estudiante("Marta", 19);
</code></pre>

      <h3>Patrones Comunes en Constructores</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Delegaci√≥n con this()</h4>
          <p>Un constructor puede invocar otro constructor de la misma clase usando <code>this(par√°metros)</code>. √ötil para evitar duplicaci√≥n de c√≥digo. <code>this()</code> debe ser la primera l√≠nea del constructor.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Validaci√≥n en Constructor</h4>
          <p>Valida todos los par√°metros antes de asignarlos a atributos. Lanza <code>IllegalArgumentException</code> si los datos son inv√°lidos. Garantiza que todo objeto nace en estado v√°lido, sin datos inconsistentes.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Constructor de Copia</h4>
          <p>Constructor que recibe otro objeto de la misma clase y copia su estado. √ötil para crear clones: <code>new Persona(otraPersona)</code>. Evita compartir referencias a objetos mutables.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Constructores Sobrecargados</h4>
          <p>M√∫ltiples constructores con diferentes firmas. Java elige autom√°ticamente seg√∫n los argumentos. Permite m√°xima flexibilidad: crear objetos con datos completos o parciales seg√∫n la situaci√≥n.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Inicializaci√≥n de Campos Finales</h4>
          <p>Los campos declarados <code>final</code> deben inicializarse en el constructor o en la declaraci√≥n. Despu√©s no pueden cambiar. Ideal para valores inmutables como IDs o nombres que nunca deben variar.</p>
        </div>
      </div>
    </section>

    <section id="ciclo-vida">
      <h2>Ciclo de Vida de un Objeto</h2>
      <p>Todo objeto en Java sigue un ciclo de vida bien definido: nacimiento, vida √∫til y muerte. Entender este ciclo es fundamental para escribir c√≥digo eficiente y sin fugas de memoria.</p>

      <h3>Fases del Ciclo de Vida</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>1. Creaci√≥n (new)</h4>
          <p><strong>Cu√°ndo:</strong> Ejecutas <code>new NombreClase()</code>. <strong>Qu√© ocurre:</strong> Se asigna memoria en el heap, se inicializan atributos a valores por defecto, se ejecuta el constructor. <strong>Resultado:</strong> Objeto listo en memoria.</p>
        </div>
        <div class="card-profesional-green">
          <h4>2. Vida √ötil (uso)</h4>
          <p><strong>Cu√°ndo:</strong> Tienes referencias v√°lidas al objeto y lo usas. <strong>Qu√© ocurre:</strong> Invocas m√©todos, lees/escribes atributos, el objeto cambia de estado. <strong>Duraci√≥n:</strong> Mientras exista al menos una referencia activa.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>3. P√©rdida de Referencias</h4>
          <p><strong>Cu√°ndo:</strong> El objeto sale de scope o todas sus referencias se eliminan. <strong>Qu√© ocurre:</strong> El objeto se vuelve inaccesible desde el c√≥digo. Java marca el objeto para garbage collection.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>4. Garbage Collection</h4>
          <p><strong>Cu√°ndo:</strong> El garbage collector (JVM) necesita liberar memoria. <strong>Qu√© ocurre:</strong> Se ejecuta <code>finalize()</code> (en versiones antiguas) y se libera la memoria. <strong>Cu√°ndo:</strong> No es determin√≠stico, ocurre cuando la JVM lo decide.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>5. Destrucci√≥n (finalize)</h4>
          <p><strong>M√©todo finalize():</strong> Se ejecuta antes de que el garbage collector libere el objeto. Rara vez se usa en c√≥digo moderno. Mejor usar try-with-resources o m√©todos cleanup() expl√≠citos para liberar recursos.</p>
        </div>
      </div>

      <h3>Ejemplo Visual del Ciclo de Vida</h3>
      <p><strong>Explicaci√≥n:</strong> Este programa demuestra el ciclo de vida completo de un objeto en Java. La FASE 1 es la creaci√≥n con <code>new</code>. La FASE 2 es el uso del objeto. La FASE 3 ocurre cuando se pierde la referencia y el objeto se vuelve inaccesible. La FASE 4 y 5 suceden autom√°ticamente cuando el garbage collector libera la memoria.</p>
      <pre><code class="language-java">// Clase de ejemplo para demostrar ciclo de vida de objetos
public class EjemploCicloVida {
    // M√©todo main: punto de entrada del programa
    public static void main(String[] args) {
        // FASE 1: CREACI√ìN - Se ejecuta 'new', se asigna memoria, se invoca constructor
        // Se crea primer objeto Persona con nombre "Ana" y edad 28
        Persona p1 = new Persona("Ana", 28);
        // Imprime confirmaci√≥n de creaci√≥n
        System.out.println("1. Objeto creado: " + p1.getNombre());

        // FASE 2: VIDA √öTIL - El objeto existe y lo usamos
        // Modifica la edad del objeto usando el m√©todo setEdad()
        p1.setEdad(29);
        // Imprime la edad modificada
        System.out.println("2. Edad modificada: " + p1.getEdad());

        // FASE 3: P√âRDIDA DE REFERENCIAS
        // Crea un segundo objeto Persona con nombre "Luis"
        Persona p2 = new Persona("Luis", 35);
        // Reasigna la variable p1 para que apunte al nuevo objeto (p2)
        p1 = p2;  // Ahora p1 apunta a Luis
        // El objeto "Ana" que p1 apuntaba est√° ahora sin referencias
        // Java marca autom√°ticamente "Ana" como candidata para garbage collection
        // "Ana" ahora es inaccesible y ser√° recolectada

        // Imprime el nuevo nombre al que apunta p1
        System.out.println("3. p1 ahora es: " + p1.getNombre());
        
        // FASE 4 y 5: GARBAGE COLLECTION Y DESTRUCCI√ìN
        // Cuando el programa termina o no hay m√°s referencias a los objetos,
        // el garbage collector (recolector de basura) de Java autom√°ticamente
        // libera la memoria ocupada por los objetos sin referencias.
        // El programador NO controla cu√°ndo ocurre exactamente.
        // p2 (Luis) tambi√©n ser√° recolectado cuando salga de scope o se pierda la referencia.
    }
}
</code></pre>
    </section>

    <section id="relaciones-objetos">
      <h2>Relaciones entre Objetos</h2>
      <p>En programaci√≥n orientada a objetos, los objetos no existen aislados. Interact√∫an con otros objetos formando relaciones que modelan el mundo real. Las relaciones permiten crear estructuras complejas y reutilizables.</p>

      <h3>Tipos Principales de Relaciones</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Asociaci√≥n</h4>
          <p>Una clase "usa" o tiene referencia a otra. Ejemplo: <code>Persona</code> tiene una referencia a <code>Direcci√≥n</code>. Las clases son independientes; pueden existir por separado. La relaci√≥n es d√©bil, sin dependencia fuerte.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Composici√≥n</h4>
          <p>Una clase "contiene" objetos de otra como partes componentes. Ejemplo: <code>Auto</code> contiene <code>Motor</code>, <code>Ruedas</code>, etc. Si la clase padre se destruye, las partes tambi√©n. Relaci√≥n fuerte: "tiene-a".</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Agregaci√≥n</h4>
          <p>Similar a composici√≥n, pero m√°s d√©bil. El todo no "posee" las partes; simplemente las agrupa. Ejemplo: <code>Equipo</code> contiene <code>Jugadores</code>. Los jugadores pueden existir sin el equipo.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Herencia</h4>
          <p>Una clase "extiende" o hereda de otra. Ejemplo: <code>Empleado</code> hereda de <code>Persona</code>. Relaci√≥n "es-un": <code>Empleado es un Persona</code>. Reutiliza c√≥digo y crea jerarqu√≠as.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Dependencia</h4>
          <p>Una clase depende de otra para funcionar, pero sin poseerla. Ejemplo: Un m√©todo recibe un par√°metro de otra clase. Relaci√≥n de corta duraci√≥n; t√≠picamente dentro de un m√©todo.</p>
        </div>
      </div>

      <h3>Ejemplo: Composici√≥n</h3>
      <p><strong>Explicaci√≥n:</strong> Composici√≥n es cuando una clase contiene objetos de otra clase. <code>Persona</code> compone una <code>Direcci√≥n</code>. Si la Persona se destruye, tambi√©n su direcci√≥n. Es una relaci√≥n fuerte de "tiene-a".</p>
      <pre><code class="language-java">// Clase Direcci√≥n: representa una ubicaci√≥n
public class Direcci√≥n {
    // Atributo private: calle de la direcci√≥n
    private String calle;
    // Atributo private: ciudad de la direcci√≥n
    private String ciudad;
    // Atributo private: c√≥digo postal de la direcci√≥n
    private String codigoPostal;

    // Constructor: inicializa todos los datos de la direcci√≥n
    public Direcci√≥n(String calle, String ciudad, String codigoPostal) {
        // Asigna la calle
        this.calle = calle;
        // Asigna la ciudad
        this.ciudad = ciudad;
        // Asigna el c√≥digo postal
        this.codigoPostal = codigoPostal;
    }

    // Sobrescribe toString para representaci√≥n legible
    @Override
    public String toString() {
        // Retorna la direcci√≥n formateada como string
        return calle + ", " + ciudad + " " + codigoPostal;
    }
}

// Clase Persona - COMPONE una Direcci√≥n
public class Persona {
    // Atributo private: nombre de la persona
    private String nombre;
    // Atributo private: edad de la persona
    private int edad;
    // Atributo private: objeto Direcci√≥n (COMPOSICI√ìN)
    // Persona "tiene-a" una Direcci√≥n como parte de s√≠ misma
    private Direcci√≥n direcci√≥n;

    // Constructor: recibe par√°metros de persona + la direcci√≥n como objeto
    public Persona(String nombre, int edad, Direcci√≥n direcci√≥n) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
        // Asigna la direcci√≥n (objeto compuesto)
        this.direcci√≥n = direcci√≥n;
    }

    // M√©todo que muestra informaci√≥n de la persona incluyendo su direcci√≥n
    public void mostrarInfo() {
        // Imprime nombre y edad de la persona
        System.out.println(nombre + ", " + edad + " a√±os");
        // Imprime la direcci√≥n (se invoca toString() autom√°ticamente)
        System.out.println("Vive en: " + direcci√≥n);
    }
}

// Clase de uso: demuestra composici√≥n en acci√≥n
public class Main {
    // M√©todo main: punto de entrada
    public static void main(String[] args) {
        // Crea un objeto Direcci√≥n primero
        Direcci√≥n dir = new Direcci√≥n("Calle Principal 123", "Madrid", "28001");
        // Crea un objeto Persona que COMPONE la Direcci√≥n
        // Persona necesita una Direcci√≥n para estar completa
        Persona p = new Persona("Ana", 28, dir);
        // Llama al m√©todo que muestra informaci√≥n
        p.mostrarInfo();
        // Salida esperada:
        // Ana, 28 a√±os
        // Vive en: Calle Principal 123, Madrid 28001
    }
}
</code></pre>
    </section>

    <section id="atributos">
      <h2>Manipulaci√≥n de Atributos</h2>
      <p>Los atributos (campos) son variables que almacenan el estado de un objeto. Se manipulan principalmente a trav√©s de getters (lectura) y setters (escritura). Una buena manipulaci√≥n de atributos es fundamental para la encapsulaci√≥n y el mantenimiento del c√≥digo.</p>

      <h3>Principios de Acceso a Atributos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Atributos Privados</h4>
          <p>Siempre usa <code>private</code> para los atributos de datos. Esto impide acceso directo no controlado desde fuera de la clase. Obliga a usar getters/setters, d√°ndote control total sobre validaci√≥n y consistencia de datos.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Getter: Lectura Segura</h4>
          <p>M√©todo p√∫blico que retorna el valor de un atributo privado. Por convenci√≥n, se nombra <code>get</code> + nombre capitalizado. <strong>Nunca</strong> modifiques el estado en un getter. Pueden retornar copias defensivas si es necesario.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Setter: Escritura Validada</h4>
          <p>M√©todo p√∫blico que modifica un atributo privado con validaci√≥n. Por convenci√≥n, se nombra <code>set</code> + nombre. Siempre valida el nuevo valor antes de asignarlo. Lanza excepciones si el valor es inv√°lido.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Copias Defensivas</h4>
          <p>Si un atributo es mutable (lista, array, objeto), retorna una copia en el getter, no la original. As√≠ evitas que c√≥digo externo modifique el estado interno sin pasar por validaciones. Importante para mantener la integridad.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Atributos Inmutables (final)</h4>
          <p>Un atributo <code>final</code> no puede cambiar despu√©s de inicializarse. Ideal para valores que deben ser constantes: IDs, nombres √∫nicos, etc. No necesita setter. Simplifica el razonamiento sobre el c√≥digo.</p>
        </div>
      </div>
      
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>Getter (M√©todo de Lectura)</h4>
          <p>Retorna el valor actual de un atributo privado. Por convenci√≥n, el nombre es <code>get</code> seguido del nombre del atributo con primera letra may√∫scula. Ej: <code>getNombre()</code>, <code>getEdad()</code>.</p>
        </div>
        <div class="card-teorico">
          <h4>Setter (M√©todo de Escritura)</h4>
          <p>Modifica el valor de un atributo privado. Por convenci√≥n, el nombre es <code>set</code> seguido del nombre del atributo. Incluye validaciones para garantizar que el nuevo valor es v√°lido antes de asignarlo.</p>
        </div>
        <div class="card-teorico">
          <h4>Atributos Privados</h4>
          <p>Usa <code>private</code> para los atributos de datos. Esto obliga a otros a usar getters/setters, permiti√©ndote controlar el acceso y validar. Nunca hagas p√∫blicos los atributos de datos.</p>
        </div>
      </div>

      <h3>Ejemplo: Validaci√≥n en Setters</h3>
      <p><strong>Explicaci√≥n:</strong> Esta clase demuestra c√≥mo usar setters para validar datos. El setter de saldo rechaza valores negativos. Los m√©todos <code>depositar()</code> y <code>retirar()</code> tambi√©n incluyen validaciones. Todos modific el estado interno de forma controlada.</p>
      <pre><code class="language-java">// Clase que representa una cuenta bancaria
public class CuentaBancaria {
    // Atributo private: nombre del titular
    private String titular;
    // Atributo private: saldo actual de la cuenta
    private double saldo;

    // Constructor: inicializa la cuenta con titular y saldo inicial
    public CuentaBancaria(String titular, double saldoInicial) {
        // Asigna el titular
        this.titular = titular;
        // Valida que el saldo inicial no sea negativo usando Math.max(0, valor)
        this.saldo = Math.max(0, saldoInicial); // no negativo
    }

    // Getter: retorna el saldo actual
    public double getSaldo() {
        // Retorna el saldo sin modificaci√≥n
        return saldo;
    }

    // Setter con validaci√≥n: modifica el saldo de forma segura
    public void setSaldo(double nuevoSaldo) {
        // Valida que el nuevo saldo sea no-negativo
        if (nuevoSaldo >= 0) {
            // Si es v√°lido, asigna el nuevo saldo
            this.saldo = nuevoSaldo;
        } else {
            // Si es inv√°lido, imprime un mensaje de error
            System.out.println("Error: el saldo no puede ser negativo");
        }
    }

    // M√©todo que realiza un dep√≥sito validado
    public void depositar(double cantidad) {
        // Valida que la cantidad sea positiva
        if (cantidad > 0) {
            // Si es v√°lida, suma la cantidad al saldo actual
            saldo += cantidad;
            // Imprime confirmaci√≥n del dep√≥sito
            System.out.println("Dep√≥sito de $" + cantidad + " exitoso. Saldo: $" + saldo);
        }
    }

    // M√©todo que realiza un retiro validado
    public void retirar(double cantidad) {
        // Valida que la cantidad sea positiva Y que haya fondos suficientes
        if (cantidad > 0 && cantidad <= saldo) {
            // Si es v√°lido, resta la cantidad del saldo
            saldo -= cantidad;
            // Imprime confirmaci√≥n del retiro
            System.out.println("Retiro de $" + cantidad + " exitoso. Saldo: $" + saldo);
        } else {
            // Si no es v√°lido, imprime un mensaje de error
            System.out.println("Operaci√≥n rechazada: fondos insuficientes o cantidad inv√°lida");
        }
    }
}
</code></pre>

      <h3>Uso de Getters y Setters</h3>
      <pre><code class="language-java">CuentaBancaria miCuenta = new CuentaBancaria("Juan", 1000);

// Leer atributo (getter)
System.out.println("Saldo: $" + miCuenta.getSaldo()); // Saldo: $1000

// Modificar atributo (setter)
miCuenta.setSaldo(1500); // Saldo v√°lido, se acepta
miCuenta.setSaldo(-500); // Saldo inv√°lido, se rechaza (error)

// Usar m√©todos que modifican atributos
miCuenta.depositar(250);  // Dep√≥sito de $250 exitoso. Saldo: $1250
miCuenta.retirar(100);    // Retiro de $100 exitoso. Saldo: $1150
miCuenta.retirar(2000);   // Error: fondos insuficientes
</code></pre>

      <h3>Validaci√≥n en Setters</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Validaci√≥n por Rango</h4>
          <p>Verifica que valores num√©ricos est√©n dentro de un rango v√°lido. Ejemplo: edad entre 0 y 150, precio mayor a 0. Usa condicionales: <code>if (valor < minimo || valor > maximo) throw new Exception()</code>.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Validaci√≥n de Null</h4>
          <p>Para atributos String o de referencia, valida que no sean null. Usa <code>if (valor == null) throw new NullPointerException()</code> o Java 16+: <code>Objects.requireNonNull(valor)</code>. Previene errores posteriores.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Validaci√≥n de Formato</h4>
          <p>Para strings, valida formato con regex o m√©todos. Ejemplo: emails con patr√≥n, tel√©fonos con longitud. Garantiza que los datos cumplen estructura esperada antes de guardarlos.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Excepciones Descriptivas</h4>
          <p>Lanza excepciones con mensajes claros. Ejemplo: <code>throw new IllegalArgumentException("Edad debe ser entre 0 y 150")</code>. El mensaje ayuda a los desarrolladores a entender y arreglar el problema r√°pido.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Validaci√≥n Combinada</h4>
          <p>Combina m√∫ltiples validaciones cuando sea necesario. Valida primero lo m√°s cr√≠tico. Usa m√©todos privados para encapsular l√≥gica de validaci√≥n compleja.</p>
        </div>
      </div>
    </section>

    <section id="mutabilidad">
      <h2>Mutabilidad e Inmutabilidad</h2>
      <p>La mutabilidad define si el estado de un objeto puede cambiar despu√©s de su creaci√≥n. Es un concepto crucial para escribir c√≥digo seguro, especialmente en programas multi-threaded.</p>

      <h3>Objetos Mutables vs Inmutables</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Objeto Mutable</h4>
          <p>Su estado puede cambiar despu√©s de crearlo. Ejemplo: <code>CuentaBancaria</code> (el saldo puede cambiar), <code>ArrayList</code> (se pueden agregar/eliminar elementos). M√°s flexible, pero requiere m√°s cuidado con la sincronizaci√≥n.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Objeto Inmutable</h4>
          <p>Su estado no puede cambiar despu√©s de crearlo. Ejemplo: <code>String</code>, <code>Integer</code> en Java. M√°s seguro en multi-threading. Si necesitas "cambiar" su estado, creas un nuevo objeto con los nuevos valores.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Crear una Clase Inmutable</h4>
          <p><strong>Pasos:</strong> 1) Declara la clase <code>final</code>. 2) Todos los atributos <code>private final</code>. 3) Inicializa en constructor, sin setters. 4) Retorna copias defensivas en getters para objetos mutables. 5) Override <code>hashCode()</code> y <code>equals()</code>.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Ventajas de Inmutabilidad</h4>
          <p><strong>1) Seguridad en threads:</strong> No necesita sincronizaci√≥n. <strong>2) Cache seguro:</strong> Se puede guardar sin preocupaciones. <strong>3) Simplicidad:</strong> Estado no cambia, f√°cil de razonar. <strong>4) Hash seguro:</strong> hashCode() nunca cambia.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Desventajas de Inmutabilidad</h4>
          <p><strong>1) Uso de memoria:</strong> Crear nuevo objeto por cada cambio consume m√°s memoria. <strong>2) Menos flexible:</strong> No puedes "actualizar" propiedades, debes recrear. <strong>3) Complejidad:</strong> Requiere copias defensivas, lo que puede ser tedioso.</p>
        </div>
      </div>

      <h3>Ejemplo: Clase Inmutable</h3>
      <p><strong>Explicaci√≥n:</strong> Clase <code>Fecha</code> es inmutable: sus atributos son <code>final</code> y no hay setters. Una vez creada, no puede cambiar. Si necesitas "modificar", creas una nueva instancia. Demuestra seguridad y previsibilidad del c√≥digo.</p>
      <pre><code class="language-java">// Clase Inmutable: no puede cambiar despu√©s de crearse
public final class Fecha {  // final: no puede heredarse (parte de ser inmutable)
    // Atributos final: no pueden cambiar despu√©s de asignarse
    private final int dia;
    // Atributo final: no puede cambiar
    private final int mes;
    // Atributo final: no puede cambiar
    private final int anio;

    // Constructor: √∫nico lugar donde se asignan valores a atributos final
    public Fecha(int dia, int mes, int anio) {
        // Valida que la fecha sea v√°lida antes de asignar
        if (!esValida(dia, mes, anio)) {
            // Lanza excepci√≥n si los datos son inv√°lidos
            throw new IllegalArgumentException("Fecha inv√°lida");
        }
        // Asigna d√≠a (solo se puede hacer en constructor o inicializador)
        this.dia = dia;
        // Asigna mes
        this.mes = mes;
        // Asigna a√±o
        this.anio = anio;
    }

    // Getters: retornan los valores, pero no hay setters (inmutabilidad)
    public int getDia() { return dia; }
    public int getMes() { return mes; }
    public int getAnio() { return anio; }

    // M√©todo privado: valida si una fecha es v√°lida
    private static boolean esValida(int d, int m, int a) {
        // Verifica mes entre 1 y 12, d√≠a entre 1 y 31, a√±o positivo
        return m >= 1 && m <= 12 && d >= 1 && d <= 31 && a > 0;
    }

    // Si necesitas "cambiar" la fecha, creas una NUEVA instancia (no modificas)
    public Fecha agregarDias(int dias) {
        // Calcula el nuevo d√≠a (l√≥gica simplificada)
        int nuevoDia = dia + dias;
        int nuevoMes = mes;
        int nuevoAnio = anio;
        // ajustar mes y a√±o si es necesario...
        // Retorna una NUEVA instancia de Fecha con los nuevos valores
        return new Fecha(nuevoDia, nuevoMes, nuevoAnio);
    }

    // Sobrescribe toString para representaci√≥n legible
    @Override
    public String toString() {
        // Retorna la fecha formateada
        return dia + "/" + mes + "/" + anio;
    }

    // Sobrescribe equals para comparar fechas l√≥gicamente
    @Override
    public boolean equals(Object obj) {
        // Si es el mismo objeto en memoria, son iguales
        if (this == obj) return true;
        // Si el otro objeto no es instancia de Fecha, no son iguales
        if (!(obj instanceof Fecha)) return false;
        // Castea el objeto a Fecha para acceder a sus atributos
        Fecha otra = (Fecha) obj;
        // Compara d√≠a, mes y a√±o
        return dia == otra.dia && mes == otra.mes && anio == otra.anio;
    }

    // Sobrescribe hashCode: importante cuando usas Fecha en HashSet o HashMap
    @Override
    public int hashCode() {
        // Calcula hash basado en los atributos
        return java.util.Objects.hash(dia, mes, anio);
    }
}

// Uso de la clase Inmutable
public class Main {
    // M√©todo main: punto de entrada
    public static void main(String[] args) {
        // Crea una fecha inmutable: 15/6/2024
        Fecha f1 = new Fecha(15, 6, 2024);
        // Imprime la fecha
        System.out.println(f1);  // Salida: 15/6/2024
        
        // NO puedo hacer f1.setDia(20) - no existe setter (porque es inmutable)
        // Si necesito otra fecha, creo una NUEVA instancia llamando agregarDias()
        // Este m√©todo retorna una nueva instancia, NO modifica f1
        Fecha f2 = f1.agregarDias(5);  // retorna nueva instancia
        // Imprime la nueva fecha
        System.out.println(f2);  // Salida: 20/6/2024
        // Imprime f1 para verificar que no cambi√≥
        System.out.println(f1);  // Salida: 15/6/2024 (f1 sigue siendo la misma)
        
        // Esto es inmutabilidad: el objeto no puede cambiar despu√©s de crearse
        // Es seguro en multi-threading y f√°cil de predecir
    }
}
</code></pre>
    </section>

    <section id="metodos">
      <h2>Manipulaci√≥n de M√©todos</h2>
      <p>Los m√©todos son funciones que definen el comportamiento de un objeto. Se invocan usando la notaci√≥n de punto: <code>objeto.metodo()</code>. Un buen dise√±o de m√©todos es clave para crear c√≥digo mantenible, reutilizable y f√°cil de entender.</p>

      <h3>Clasificaci√≥n de M√©todos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>M√©todos sin Retorno (void)</h4>
          <p>Ejecutan una acci√≥n pero no retornan valor. Sintaxis: <code>public void nombreMetodo() { ... }</code>. Se usan para modificar el estado interno o realizar operaciones sin resultado. Ejemplo: <code>depositar()</code>, <code>saludar()</code>.</p>
        </div>
        <div class="card-profesional-green">
          <h4>M√©todos con Retorno</h4>
          <p>Ejecutan c√°lculos/consultas y devuelven un resultado. Especifican el tipo: <code>int</code>, <code>String</code>, <code>boolean</code>, objetos, etc. Sintaxis: <code>public TipoRetorno nombreMetodo() { return valor; }</code>. Ejemplo: <code>calcularSaldo()</code>.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>M√©todos con Par√°metros</h4>
          <p>Reciben uno o m√°s argumentos para procesarlos. Aumentan la reutilizaci√≥n: mismo m√©todo, diferentes datos. Sintaxis: <code>public void metodo(Tipo param1, Tipo param2) { ... }</code>. Los par√°metros son locales al m√©todo.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>M√©todos Privados</h4>
          <p>Usa <code>private</code> para m√©todos que solo la clase usa internamente. Encapsulan l√≥gica compleja y detalles de implementaci√≥n. No son parte de la interfaz p√∫blica. Facilita cambios internos sin afectar otros c√≥digos.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>M√©todos Est√°ticos</h4>
          <p>Declarados con <code>static</code>. Pertenecen a la clase, no a instancias. Se invocan en la clase: <code>NombreClase.metodo()</code>. √ötiles para utilidades: <code>Math.max()</code>, <code>System.out.println()</code>. No pueden acceder a atributos de instancia.</p>
        </div>
      </div>
      
      <div class="cards-grid-teoricos">
        <div class="card-teorico">
          <h4>M√©todos sin Retorno (void)</h4>
          <p>Ejecutan una acci√≥n pero no devuelven un resultado. Ejemplo: <code>depositar()</code>, <code>saludar()</code>. Se usan para modificar el estado o realizar operaciones sin necesidad de valores de salida.</p>
        </div>
        <div class="card-teorico">
          <h4>M√©todos con Retorno</h4>
          <p>Ejecutan una acci√≥n y devuelven un valor. El tipo de retorno especifica qu√© tipo de dato retorna: <code>int</code>, <code>String</code>, <code>boolean</code>, etc. Se usan para c√°lculos, b√∫squedas y consultas.</p>
        </div>
        <div class="card-teorico">
          <h4>M√©todos con Par√°metros</h4>
          <p>Reciben uno o m√°s argumentos para procesar. Los par√°metros permiten que un m√©todo se comporte diferente seg√∫n los datos que reciba. Facilita la reutilizaci√≥n de c√≥digo.</p>
        </div>
      </div>

      <h3>Estructura de un M√©todo</h3>
      <pre><code class="language-java">modificador tipoRetorno nombreMetodo(parametro1, parametro2, ...) {
    // cuerpo del m√©todo
    return valor; // si tipoRetorno != void
}

// Ejemplos
public void saludar(String nombre) {
    System.out.println("¬°Hola, " + nombre + "!");
}

public int sumar(int a, int b) {
    return a + b;
}

public boolean esAdulto(int edad) {
    return edad >= 18;
}

public String obtenerInfo() {
    return "Informaci√≥n del objeto";
}
</code></pre>

      <h3>Invocaci√≥n de M√©todos</h3>
      <p><strong>Explicaci√≥n:</strong> Esta clase demuestra diferentes tipos de m√©todos: sin par√°metros ni retorno (<code>saludar()</code>), con par√°metros sin retorno (<code>cumpleanios()</code>), con retorno (<code>esAdulto()</code>), y con par√°metros y retorno (<code>presentarse()</code>).</p>
      <pre><code class="language-java">// Clase que demuestra diferentes tipos de m√©todos
public class Persona {
    // Atributo private: nombre
    private String nombre;
    // Atributo private: edad
    private int edad;

    // Constructor: inicializa la persona
    public Persona(String nombre, int edad) {
        // Asigna el nombre
        this.nombre = nombre;
        // Asigna la edad
        this.edad = edad;
    }

    // M√©todo 1: Sin par√°metros, sin retorno (void)
    // Prop√≥sito: ejecutar una acci√≥n sin datos de entrada ni salida
    public void saludar() {
        // Imprime un saludo usando el nombre de la persona
        System.out.println("Hola, soy " + nombre);
    }

    // M√©todo 2: Sin par√°metros, sin retorno (void)
    // Prop√≥sito: modificar el estado interno (incrementar edad)
    public void cumpleanios() {
        // Incrementa la edad en 1
        edad++;
        // Imprime el nuevo estado
        System.out.println(nombre + " ahora tiene " + edad + " a√±os");
    }

    // M√©todo 3: Sin par√°metros, con retorno booleano
    // Prop√≥sito: consultar si la persona cumple una condici√≥n
    public boolean esAdulto() {
        // Retorna true si edad es 18 o m√°s, false si no
        return edad >= 18;
    }

    // M√©todo 4: Con par√°metros (String) y con retorno (String)
    // Prop√≥sito: usar datos externos y retornar un resultado construido
    public String presentarse(String saludo) {
        // Retorna un string que combina el saludo con informaci√≥n de la persona
        return saludo + ", me llamo " + nombre + " y tengo " + edad + " a√±os";
    }
}

// Clase de uso: demuestra c√≥mo invocar los diferentes m√©todos
public class Main {
    // M√©todo main: punto de entrada
    public static void main(String[] args) {
        // Crea una instancia de Persona: Ana, 25 a√±os
        Persona p = new Persona("Ana", 25);

        // Invoca m√©todo 1: sin par√°metros, sin retorno
        // La acci√≥n se ejecuta (imprime) pero no retorna nada
        p.saludar();                           // Salida: Hola, soy Ana
        
        // Invoca m√©todo 2: sin par√°metros, sin retorno
        // Modifica el estado (incrementa edad) y imprime
        p.cumpleanios();                       // Salida: Ana ahora tiene 26 a√±os
        
        // Invoca m√©todo 3: sin par√°metros, con retorno booleano
        // Retorna un valor booleano que imprimimos
        System.out.println(p.esAdulto());      // Salida: true (26 >= 18)
        
        // Invoca m√©todo 4: con par√°metro String, con retorno String
        // Pasa "Buenos d√≠as" como argumento, retorna un string que imprimimos
        System.out.println(p.presentarse("Buenos d√≠as")); 
        // Salida: Buenos d√≠as, me llamo Ana y tengo 26 a√±os
    }
}
</code></pre>
    </section>

    <section id="buenas-practicas-metodos">
      <h2>Buenas Pr√°cticas en M√©todos</h2>
      <p>El dise√±o de m√©todos es cr√≠tico para la calidad del c√≥digo. M√©todos bien dise√±ados son f√°ciles de entender, probar, mantener y reutilizar.</p>

      <h3>Principios de Buen Dise√±o de M√©todos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Responsabilidad √önica</h4>
          <p><strong>Single Responsibility Principle (SRP):</strong> Cada m√©todo debe hacer una sola cosa bien. Si un m√©todo hace m√∫ltiples cosas, div√≠delo en varios m√©todos. Un m√©todo con una responsabilidad clara es f√°cil de entender, probar y mantener.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Nombres Descriptivos</h4>
          <p>Nombres deben ser verbos que describan la acci√≥n: <code>calcular</code>, <code>validar</code>, <code>obtener</code>, <code>establecer</code>. Evita nombres gen√©ricos como <code>procesar</code> o <code>hacer</code>. Un buen nombre es documentaci√≥n en s√≠ misma; debe ser auto-explicativo.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Par√°metros M√≠nimos</h4>
          <p>Limita el n√∫mero de par√°metros (idealmente ‚â§ 3). Muchos par√°metros hace m√©todos confusos y dif√≠ciles de invocar. Si necesitas muchos, agr√∫palos en un objeto: <code>metodo(ConfiguracionObjeto config)</code> en lugar de <code>metodo(int a, int b, int c, ...)</code>.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>Sin Efectos Secundarios</h4>
          <p>M√©todos no deber√≠an modificar estado global o externo inesperadamente. Si un m√©todo dice "obtener", deber√≠a solo retornar sin cambiar nada. Si modifica estado, el nombre debe indicarlo: <code>depositar()</code> en lugar de solo <code>obtenerSaldo()</code>.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>Documentaci√≥n con Javadoc</h4>
          <p>Documenta m√©todos p√∫blicos con Javadoc: <code>/** ... @param ... @return ... @throws ... */</code>. Especifica qu√© hace, par√°metros, retorno y excepciones. Herramientas generan documentaci√≥n autom√°ticamente. Facilita uso correcto por otros desarrolladores.</p>
        </div>
      </div>

      <h3>Ejemplo: M√©todo Bien Dise√±ado</h3>
      <p><strong>Explicaci√≥n:</strong> Este ejemplo muestra c√≥mo dise√±ar un m√©todo de forma profesional: con validaciones claras, documentaci√≥n Javadoc, responsabilidad √∫nica y m√©todos auxiliares privados que encapsulan complejidad.</p>
      <pre><code class="language-java">/**
 * M√©todo bien documentado con Javadoc
 * Valida y procesa un dep√≥sito en la cuenta.
 * 
 * @param monto la cantidad a depositar, debe ser mayor a 0
 * @throws IllegalArgumentException si monto es negativo o cero
 * @return true si el dep√≥sito fue exitoso, false en caso contrario
 */
public boolean procesarDeposito(double monto) {
    // Una responsabilidad clara: procesar dep√≥sito
    // Valida que el monto sea positivo
    if (monto <= 0) {
        // Lanza una excepci√≥n con mensaje descriptivo
        throw new IllegalArgumentException("Monto debe ser positivo");
    }
    
    // Si es v√°lido, suma el monto al saldo actual
    saldo += monto;
    // Llama a m√©todo privado auxiliar para encapsular l√≥gica de registro
    registrarTransacci√≥n("Dep√≥sito", monto);
    // Retorna true indicando √©xito
    return true;
}

/**
 * M√©todo privado auxiliar: encapsula la l√≥gica de registrar transacciones.
 * No forma parte de la interfaz p√∫blica.
 * 
 * @param tipo el tipo de transacci√≥n (ej: "Dep√≥sito", "Retiro")
 * @param monto el monto de la transacci√≥n
 */
private void registrarTransacci√≥n(String tipo, double monto) {
    // Imprime informaci√≥n de transacci√≥n con timestamp (hora actual)
    System.out.println("[" + java.time.LocalDateTime.now() + "] " + tipo + ": $" + monto);
}
</code></pre>

      <h3>Patrones Comunes de M√©todos</h3>
      <div class="cards-grid-profesional">
        <div class="card-profesional-blue">
          <h4>Constructor</h4>
          <p><code>public NombreClase(...)</code>. M√©todo especial que inicializa objetos. Mismo nombre que la clase. Ejecuta autom√°ticamente con <code>new</code>. Encapsula l√≥gica de inicializaci√≥n.</p>
        </div>
        <div class="card-profesional-green">
          <h4>Getter</h4>
          <p><code>public Tipo get NombreAtributo()</code>. Retorna valor de atributo privado. Lectura segura. Por convenci√≥n: <code>getNombre()</code>, <code>getEdad()</code>. Puede validar o retornar copia.</p>
        </div>
        <div class="card-profesional-purple">
          <h4>Setter</h4>
          <p><code>public void setNombreAtributo(Tipo valor)</code>. Modifica atributo con validaci√≥n. Escritura segura. Por convenci√≥n: <code>setNombre()</code>. Lanza excepciones si datos inv√°lidos.</p>
        </div>
        <div class="card-profesional-amber">
          <h4>toString()</h4>
          <p><code>public String toString()</code>. Retorna representaci√≥n en texto del objeto. √ötil para debugging y logging. Sobrescribe el m√©todo de <code>Object</code>. Ejemplo: <code>"Persona{nombre='Ana', edad=28}"</code>.</p>
        </div>
        <div class="card-profesional-rose">
          <h4>equals()</h4>
          <p><code>public boolean equals(Object obj)</code>. Compara si dos objetos son iguales l√≥gicamente. Sobrescribe el m√©todo de <code>Object</code>. Importante para colecciones: List, Set, Map. Siempre paired con <code>hashCode()</code>.</p>
        </div>
      </div>
    </section>

      <h2>Ejercicio Pr√°ctico</h2>

      <h3>Clase Autom√≥vil con M√©todos</h3>
      <p><strong>Enunciado:</strong> Crea una clase <code>Automovil</code> con marca, modelo, a√±o y velocidad actual. Implementa m√©todos para acelerar, frenar, obtener velocidad m√°xima seg√∫n el modelo.</p>

      <div class="solution">
        <h3>Soluci√≥n Compilable</h3>
        <pre><code class="language-java">// Clase Autom√≥vil
class Automovil {
    private String marca, modelo;
    private int anio;
    private double velocidad;
    private double velMax;

    // Constructor
    public Automovil(String marca, String modelo, int anio, double velMax) {
        this.marca = marca;
        this.modelo = modelo;
        this.anio = anio;
        this.velocidad = 0;
        this.velMax = velMax;
    }

    // Acelerar - no puede exceder velocidad m√°xima
    public void acelerar(double incremento) {
        velocidad = Math.min(velocidad + incremento, velMax);
    }

    // Frenar - no puede ser negativa
    public void frenar(double decremento) {
        velocidad = Math.max(velocidad - decremento, 0);
    }

    public double getVelocidad() { return velocidad; }

    @Override
    public String toString() {
        return marca + " " + modelo + " (" + anio + ") - Vel: " + velocidad + " km/h";
    }
}

// Programa Principal
public class Main {
    public static void main(String[] args) {
        // Crear autom√≥vil con velocidad m√°xima de 200 km/h
        Automovil auto = new Automovil("Toyota", "Sedan", 2023, 200);

        // Acelerar
        auto.acelerar(50);   // 50 km/h
        System.out.println(auto);

        auto.acelerar(100);  // 150 km/h
        System.out.println(auto);

        auto.acelerar(100);  // Intenta 250, pero m√°ximo es 200
        System.out.println(auto);

        // Frenar
        auto.frenar(30);     // 170 km/h
        System.out.println(auto);
    }
}
</code></pre>
      </div>
    </section>

    <h3>Cards de Refuerzo: Instanciaci√≥n y Manipulaci√≥n</h3>
    <div class="cards-grid-teoricos">
      <div class="card-teorico">
        <h4>Operador new</h4>
        <p>Crea una nueva instancia de una clase en memoria. Sintaxis: <code>new NombreClase(argumentos)</code>. Invoca autom√°ticamente el constructor que coincida con los argumentos proporcionados.</p>
      </div>
      <div class="card-teorico">
        <h4>Constructor</h4>
        <p>M√©todo especial que inicializa un objeto. Tiene el mismo nombre que la clase. Se ejecuta autom√°ticamente al crear una instancia. Puede validar datos y establecer valores iniciales.</p>
      </div>
      <div class="card-teorico">
        <h4>Sobrecarga de Constructores</h4>
        <p>M√∫ltiples constructores con diferentes firmas. Java elige el correcto seg√∫n los argumentos. Permite flexibilidad en c√≥mo crear objetos con distintos conjuntos de datos iniciales.</p>
      </div>
      <div class="card-teorico">
        <h4>Getters y Setters</h4>
        <p>M√©todos p√∫blicos para acceder (get) y modificar (set) atributos privados. Los setters pueden validar datos. Es la forma encapsulada y segura de acceder a los datos de un objeto.</p>
      </div>
      <div class="card-teorico">
        <h4>Referencias de Objetos</h4>
        <p>Las variables que guardan objetos son referencias (apuntadores) a ubicaciones en memoria, no copias. M√∫ltiples variables pueden apuntar al mismo objeto. Asignar a otra variable copia la referencia, no el objeto.</p>
      </div>
      <div class="card-teorico">
        <h4>Estado Independiente</h4>
        <p>Cada instancia tiene su propio estado (valores de atributos) independiente. Cambiar un atributo en una instancia no afecta a otras, aunque sean de la misma clase.</p>
      </div>
    </div>

    <h3>Buenas Pr√°cticas</h3>
    <div class="info-box">
      <ol>
        <li><strong>Usa constructores para inicializar:</strong> establece valores iniciales v√°lidos en el constructor, no despu√©s de crear el objeto.</li>
        <li><strong>Valida en constructores y setters:</strong> aseg√∫rate de que los datos sean v√°lidos antes de asignarlos. Lanza excepciones si es necesario.</li>
        <li><strong>Mant√©n atributos privados:</strong> siempre usa <code>private</code> para atributos de datos; proporciona getters/setters p√∫blicos para acceso controlado.</li>
        <li><strong>Nombra getters/setters convencionalmente:</strong> usa <code>getNombre()</code>, <code>setNombre()</code> para que otros programadores reconozcan f√°cilmente estos m√©todos.</li>
        <li><strong>Evita l√≥gica compleja en getters/setters:</strong> estos m√©todos deben ser simples. Si necesitas l√≥gica compleja, crea m√©todos separados.</li>
        <li><strong>Proporciona constructores √∫tiles:</strong> crea m√∫ltiples constructores (sobrecarga) para permitir diferentes formas de crear objetos con datos iniciales relevantes.</li>
        <li><strong>Usa <code>this</code> expl√≠citamente en constructores:</strong> especifica <code>this.atributo = parametro</code> para claridad al leer el c√≥digo.</li>
      </ol>
    </div>

    <section id="videos-educativos">
      <h2>Videos Educativos</h2>
      <div class="videos-grid">
        <div class="video-container">
          <h3>Instanciaci√≥n de Objetos en Java</h3>
          <div class="video-wrapper">
            <video controls width="100%" height="400" class="video-player">
              <source src="videos/Instanciacion.mp4" type="video/mp4">
              Tu navegador no soporta la reproducci√≥n de video. <a href="videos/Instanciacion.mp4" download>Descargar video</a>
            </video>
          </div>
          <p>Aprende c√≥mo declarar, instanciar e inicializar objetos en Java.</p>
        </div>
      </div>
    </section>

    <div style="text-align:center;margin:40px 0;padding:25px;background:linear-gradient(135deg,rgba(43,108,176,0.08),rgba(72,187,120,0.05));border-radius:12px;border:2px solid rgba(43,108,176,0.15);">
      <p style="margin:0 0 15px 0;font-weight:600;color:var(--accent);">üìö Recursos adicionales</p>
      <p class="muted" style="margin:0 0 20px 0;"><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html" target="_blank" rel="noopener">Classes and Objects (Oracle)</a> ‚Ä¢ <a href="https://www.geeksforgeeks.org/constructors-in-java/" target="_blank" rel="noopener">Constructors in Java (GeeksforGeeks)</a></p>
      <a href="index.html" style="display:inline-block;background:linear-gradient(135deg,var(--accent),#0284c7);color:white;padding:12px 28px;border-radius:8px;text-decoration:none;font-weight:600;transition:all 0.3s ease;">üè† Volver al inicio</a>
    </div>
  </main>

  <footer class="site-footer">
    <p>¬© P√°gina web POO 2026 - Programaci√≥n Orientada a Objetos</p>
    <p>Kevin Zapata - Todos los derechos reservados</p>
    <p>Educaci√≥n Superior TSUDS - ITECSUR</p>
  </footer>
  
  <!-- Botones de navegaci√≥n profesional -->
  <div class="nav-buttons-container">
    <button class="nav-button top" data-tooltip="Ir al principio" onclick="scrollToTop()">‚Üë</button>
    <button class="nav-button" data-tooltip="Subir p√°gina" onclick="scrollUp()">‚Üë</button>
    <button class="nav-button" data-tooltip="Bajar p√°gina" onclick="scrollDown()">‚Üì</button>
    <button class="nav-button bottom" data-tooltip="Ir al final" onclick="scrollToBottom()">‚Üì</button>
  </div>
  
  <script src="js/main.js"></script>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    
    function scrollUp() {
      window.scrollBy({ top: -window.innerHeight * 0.8, behavior: 'smooth' });
    }
    
    function scrollDown() {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
    }
  </script>
</body>
</html>
